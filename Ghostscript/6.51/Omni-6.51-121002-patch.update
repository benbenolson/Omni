diff -ur src/defs.h ghostscript-6.51-121002/src/defs.h
--- src/defs.h	2002-12-13 10:19:47.000000000 -0600
+++ src/defs.h	2002-12-13 10:19:50.000000000 -0600
@@ -36,9 +36,13 @@
 #define APIENTRY
 #define LOCAL
 
-
-#define TRUE  1
-#define FALSE 0
+#ifndef FALSE
+#define FALSE   (0)
+#endif
+
+#ifndef TRUE
+#define TRUE    (!FALSE)
+#endif
 
 typedef unsigned char BYTE;
 
@@ -85,7 +89,7 @@
 } POINTL;
 typedef POINTL *PPOINTL;
 
-typedef struct _RECTL {                 // rcl
+typedef struct _RECTL {                 /* rcl */
     LONG  xLeft;
     LONG  yBottom;
     LONG  xRight;
@@ -93,12 +97,12 @@
 } RECTL;
 typedef RECTL *PRECTL;
 
-typedef struct _RGB {                   // rgb
+typedef struct _RGB {                   /* rgb */
     BYTE bBlue;
     BYTE bGreen;
     BYTE bRed;
 } RGB;
-//typedef RGB *PRGB;
+/* typedef RGB *PRGB; */
 
 typedef LONG APIRET;
 
@@ -256,13 +260,13 @@
 } IMAGEINFOS;
 typedef IMAGEINFOS * PIMAGEINFO;    /* pimginfo */
 
-#define  GDM_NO_DITHER               0x0000   // No dithering in system
-#define  GDM_USERDEF_DITHER          0x0001   // Users supplies own Dithering routines
-#define  GDM_MATRIX_DITHER           0x0002   // Use System ordered dithering
-#define  GDM_ERRORDIF_DITHER         0x0004   // Use System error diffusion dithering
-#define  GDM_DITHER_BEGIN            0x0008   // Use System Floyd-Steinberg dithering
-#define  GDM_DITHER_END              0x0010   // Use System error propigation dithering
-#define  GDM_COLOR_CONVERT           0x0020   // use device's clr mapping functions
+#define  GDM_NO_DITHER               0x0000   /* No dithering in system                 */
+#define  GDM_USERDEF_DITHER          0x0001   /* Users supplies own Dithering routines  */
+#define  GDM_MATRIX_DITHER           0x0002   /* Use System ordered dithering           */
+#define  GDM_ERRORDIF_DITHER         0x0004   /* Use System error diffusion dithering   */
+#define  GDM_DITHER_BEGIN            0x0008   /* Use System Floyd-Steinberg dithering   */
+#define  GDM_DITHER_END              0x0010   /* Use System error propigation dithering */
+#define  GDM_COLOR_CONVERT           0x0020   /* use device's clr mapping functions     */
 
 
 /*******************************************************************************************/
@@ -301,7 +305,7 @@
 typedef struct _DIFFUSIONDITHERINFO      /* difdi */
 {
    ULONG       ulLength;
-   ULONG       ulType;        // Stucki, user defined, etc.
+   ULONG       ulType;        /* Stucki, user defined, etc. */
    ULONG       fOptions;
    ULONG       ulIntensity;
    BYTE        bRedWt;
diff -ur src/gomni.c ghostscript-6.51-121002/src/gomni.c
--- src/gomni.c	2002-12-13 10:19:47.000000000 -0600
+++ src/gomni.c	2002-12-13 10:19:50.000000000 -0600
@@ -88,7 +88,7 @@
 /*                                                                      */
 /************************************************************************/
 
-// Include these first.  Ghostscript redefines printf
+/* Include these first.  Ghostscript redefines printf */
 #include <glib.h>
 #include <gmodule.h>
 
@@ -124,7 +124,7 @@
 typedef struct _HWRES {
   float xRes;
   float yRes;
-  float fScanDots;  // number of dots in scan line
+  float fScanDots;  /* number of dots in scan line */
 } HWRESOLUTION;
 
 typedef struct _PRTMODE {
@@ -148,7 +148,7 @@
                                         HWMARGINS    *hwMargins);
 typedef void   (*PFNBEGINJOB)          (void         *pOmni,
                                         FILE         *pfpOut);
-typedef void   (*PFNNEWFRAME)          (void         *pDev); //@@04162001
+typedef void   (*PFNNEWFRAME)          (void         *pDev); /*@@04162001*/
 typedef void   (*PFNENDJOB)            (void         *pDev);
 typedef void   (*PFNRASTERIZE)         (void         *pcoreOmni,
                                         PBYTE         pbBits,
@@ -160,7 +160,7 @@
                                         void        **vhDevice,
                                         int           iUsePDC);
 typedef void * (*PFNDELETEDEVICE)      (void         *pOmni);
-typedef long   (*PFNMONODITHER)        (PDDI          pdi,           //@@04062001
+typedef long   (*PFNMONODITHER)        (PDDI          pdi,           /*@@04062001*/
                                         PIMAGEINFO    pimg_infos,
                                         PBYTE        *pBuffer,
                                         ULONG         ulFlgs);
@@ -185,15 +185,15 @@
 
 typedef struct omni_dev_struct {
     char  cSignature[4];
-    int   cbSize;                     // length of the structure
+    int   cbSize;                     /* length of the structure */
     char  cVersion[10];
     char  cOmniVersion[10];
-    bool  bPDCDevice;                 // boolean to tell if this is a PDC device or not
-    void *pDevice;                    // pointer to a device
-    FILE *pfpOut;                     // pointer to the output handle from beginjob
+    bool  bPDCDevice;                 /* boolean to tell if this is a PDC device or not */
+    void *pDevice;                    /* pointer to a device */
+    FILE *pfpOut;                     /* pointer to the output handle from beginjob */
     FILE *pfpErr;
-    char *pszJobOptions;              // pointer to the job options
-    char  cDebugFile[MAX_LENGTH];     // debug file name
+    char *pszJobOptions;              /* pointer to the job options */
+    char  cDebugFile[MAX_LENGTH];     /* debug file name */
     char  cDeviceName[MAX_LENGTH];
     char  cServer[64];
     void *pvReserved;
@@ -203,22 +203,22 @@
 typedef struct _DevStruct {
    char                  cAsyncOpt[MAX_LENGTH];      /* text value for dither */
    char                  cMonoDither[MAX_LENGTH];
-   char                  cServerFile[256];           //@@05092001
+   char                  cServerFile[256];           /*@@05092001 */
    core_omni_device     *pcoreOmni;
    void                 *pCallPtr;
 
-   GModule              *hmodOmni;                   // handle to libomni.so
-   GModule              *hmodDevice;                 // handle to libDeviceXXX.so
+   GModule              *hmodOmni;                   /* handle to libomni.so */
+   GModule              *hmodDevice;                 /* handle to libDeviceXXX.so */
    PFNGETPRINTMODEINFO   pfnGetPrintModeInfo;
    PFNGETRESOLUTIONINFO  pfnGetResolutionInfo;
    PFNGETMARGININFO      pfnGetMarginInfo;
    PFNBEGINJOB           pfnBeginJob;
-   PFNNEWFRAME           pfnNewFrame;                //@@04162001
+   PFNNEWFRAME           pfnNewFrame;                /*@@04162001*/
    PFNENDJOB             pfnEndJob;
    PFNRASTERIZE          pfnRasterize;
    PFNCREATEDEVICE       pfnCreateDevice;
    PFNDELETEDEVICE       pfnDeleteDevice;
-   PFNMONODITHER         pfnMonoDither;              //@@04162001
+   PFNMONODITHER         pfnMonoDither;              /*@@04162001*/
    PFNGIINIT             pfnGIInit;
    PFNGITERM             pfnGITerm;
    unsigned long         ulPelSizeCorrection;
@@ -227,11 +227,11 @@
    int                   width;
    int                   height;
    int                   iSync;
-   int                   iPageNumber;                //@@04162001
-   int                   iGSMono;                    //@@04252001
-   int                   iUseServer;                 //@@05092001
+   int                   iPageNumber;                /*@@04162001 */
+   int                   iGSMono;                    /*@@04252001 */
+   int                   iUseServer;                 /*@@05092001 */
    int                   iUseDialog;
-   FILE                 *ProxyFile;                  //@@05092001
+   FILE                 *ProxyFile;                  /*@@05092001 */
 
    byte                 *outbuf;                     /* Output-Buffer */
 
@@ -294,23 +294,21 @@
 /* 24-bit color. only want 16M colors  */
 
 private gx_device_procs omni16m_procs = {
-                  OpenDevice,                     //  open_device
-                  NULL,                           //  get_initial_matrix
-                  NULL,                           //  sync_output
-//////////////////gx_default_sync_output,         // sync_output
-                  gdev_prn_output_page,           //  output_page
-                  CloseDevice,                    //  close_device
-                  NULL, // bmp_map_16m_rgb_color, //  map_rgb_color      @@04252001
-                  NULL, // bmp_map_16m_color_rgb, //  map_color_rgb     @@04252001
-                  NULL,                           /** fill_rectangle */
-                  NULL,                           /** tile_rectangle */
-                  NULL,                           /** copy_mono */
-                  NULL,                           /** copy_color */
-                  NULL,                           /** draw_line */
-//////////////////NULL,                           // Reads scan lines
-                  gx_default_get_bits,            // Reads scan lines
-                  GetDeviceParams,                /** Export parameters, special */
-                  SetupDevice                     /** Import parameters, special */
+                  OpenDevice,                       /*  open_device */
+                  NULL,                             /*  get_initial_matrix */
+                  NULL,                             /*  sync_output */
+                  gdev_prn_output_page,             /*  output_page */
+                  CloseDevice,                      /*  close_device */
+                  NULL, /* bmp_map_16m_rgb_color,*/ /*  map_rgb_color      @@04252001 */
+                  NULL, /* bmp_map_16m_color_rgb,*/ /*  map_color_rgb      @@04252001 */
+                  NULL,                             /** fill_rectangle */
+                  NULL,                             /** tile_rectangle */
+                  NULL,                             /** copy_mono */
+                  NULL,                             /** copy_color */
+                  NULL,                             /** draw_line */
+                  gx_default_get_bits,              /* Reads scan lines */
+                  GetDeviceParams,                  /** Export parameters, special */
+                  SetupDevice                       /** Import parameters, special */
 };
 
 
@@ -321,9 +319,8 @@
                DEFAULT_HEIGHT_10THS,
                X_DPI, Y_DPI,         /* std resolution - 72 dpi          */
                0,0,0,0,              /* margins - need defaults  */
-///////////////24,                   // @@04252001
                1,                    /* Bpp value */
-               omni_print_page);     // sync routine for output of raster data
+               omni_print_page);     /* sync routine for output of raster data */
 
 
 /* ------------------------------------------------------*/
@@ -392,8 +389,8 @@
       return e_Fatal;
    }
 
-   pDev->iUseServer  = 0;  //@@05092001
-   pDev->iPageNumber = 0;  //@@04162001
+   pDev->iUseServer  = 0;
+   pDev->iPageNumber = 0;
    pDev->iUseDialog  = 0;
 
    /*
@@ -409,20 +406,20 @@
    }
    else
    {
-      // don't really think this needs to be done but we'll do it anyway
+      /* don't really think this needs to be done but we'll do it anyway */
       set_dev_proc (pdev, sync_output, gx_default_sync_output);
    }
 
    set_dev_proc (pdev, put_params, SetupDevice);
    set_dev_proc (pdev, get_params, GetDeviceParams);
 
-   if (!pDev->iGSMono)                                                 //@@04252001
-   {                                                                   //@@04252001
+   if (!pDev->iGSMono)
+   {
       if (fDebugOutput) fprintf(stderr, "Remapping color pointers\n");
 
-      set_dev_proc(pdev, map_rgb_color, bmp_map_16m_rgb_color);        //@@04252001
-      set_dev_proc(pdev, map_color_rgb, bmp_map_16m_color_rgb);        //@@04252001
-   }                                                                   //@@04252001
+      set_dev_proc(pdev, map_rgb_color, bmp_map_16m_rgb_color);
+      set_dev_proc(pdev, map_color_rgb, bmp_map_16m_color_rgb);
+   }
 
    if (pDev->iSync)
    {
@@ -471,7 +468,7 @@
       fprintf (stderr, "Error: No device handle in CloseDevice\n");
       if (fDebugOutput) fprintf (stderr, "@ line %d gomni.c\n", __LINE__);
 
-      return_error (gs_error_Fatal);  // handle no pDev
+      return_error (gs_error_Fatal);  /* handle no pDev */
    }
 
    if (  pDev->pcoreOmni
@@ -480,7 +477,6 @@
       )
    {
        pDev->pfnEndJob ((void*)pDev->pCallPtr);
-       pDev->pfnEndJob = 0;
    }
 
    if (  pDev->pcoreOmni
@@ -496,6 +492,7 @@
       )
    {
       pDev->pfnDeleteDevice (pDev->pcoreOmni->pDevice);
+      pDev->pcoreOmni->pDevice = 0;
    }
 
    if (pDev->pfnGITerm)
@@ -613,15 +610,15 @@
    strdata.persistent = bPersist;
    iReturnCode = param_write_string(plist,"monodither",&strdata);
 
-   strdata.data = pszServer;                                      //@@05092001
-   strdata.size = strlen(pszServer);                              //@@05092001
-   strdata.persistent = bPersist;                                 //@@05092001
-   iReturnCode = param_write_string(plist,"server",&strdata);     //@@05092001
-
-   strdata.data = pszServer;                                      //@@05092001
-   strdata.size = strlen(pszServer);                              //@@05092001
-   strdata.persistent = bPersist;                                 //@@05092001
-   iReturnCode = param_write_string(plist,"jobdialog",&strdata);  //@@05092001
+   strdata.data = pszServer;
+   strdata.size = strlen(pszServer);
+   strdata.persistent = bPersist;
+   iReturnCode = param_write_string(plist,"server",&strdata);
+
+   strdata.data = pszServer;
+   strdata.size = strlen(pszServer);
+   strdata.persistent = bPersist;
+   iReturnCode = param_write_string(plist,"jobdialog",&strdata);
 
    iReturnCode = param_write_long(plist,"PelSizeCorrection",&ulPelSizeCorrection);
 
@@ -659,14 +656,14 @@
       "/opt/Omni/bin/",
       "/opt/Omni/lib/",
       "./",
-      ""                // give a chance for $LD_LIBRARY_PATH to work
+      ""                /* give a chance for $LD_LIBRARY_PATH to work*/
    };
-   PRINTMODE               prtMode;           // definition of printed output Bpp ..
+   PRINTMODE               prtMode;           /* definition of printed output Bpp ..*/
    gs_param_string         fname;
 
    if (fDebugOutput) fprintf (stderr, "SetupDevice: pDev = %08X\n", (int)pDev);
 
-   // Do we have a handle?
+   /* Do we have a handle? */
    if (pDev == NULL)
    {
       PDEVSTRUCT p;
@@ -705,9 +702,31 @@
 
    if (fDebugOutput) fprintf (stderr, "SetupDevice: pDev->hmodOmni = %08X\n", (int)pDev->hmodOmni);
 
-   // Is the handle initialized?
+   /* Is the handle initialized? */
    if (!pDev->hmodOmni)
    {
+      #define dimof(a) (sizeof (a)/sizeof (a[0]))
+      typedef struct _EntryPointList {
+         char     *pszEntryPoint;
+         gpointer *pfnEntryPoint;
+      } ENTRYPOINTLIST, *PENTRYPOINTLIST;
+      ENTRYPOINTLIST aeplEntryPoints[] = {
+         { "GetPrintModeInfo",         (gpointer *)&pDev->pfnGetPrintModeInfo  },
+         { "GetResolutionInfo",        (gpointer *)&pDev->pfnGetResolutionInfo },
+         { "GetMarginInfo",            (gpointer *)&pDev->pfnGetMarginInfo     },
+         { "BeginJob",                 (gpointer *)&pDev->pfnBeginJob          },
+         { "NewFrame",                 (gpointer *)&pDev->pfnNewFrame          },
+         { "EndJob",                   (gpointer *)&pDev->pfnEndJob            },
+         { "Rasterize",                (gpointer *)&pDev->pfnRasterize         },
+         { "CreateDevice",             (gpointer *)&pDev->pfnCreateDevice      },
+         { "DeleteDevice",             (gpointer *)&pDev->pfnDeleteDevice      },
+         { "DiffusionDither",          (gpointer *)&pDev->pfnMonoDither        },
+         { "GhostscriptInferfaceInit", (gpointer *)&pDev->pfnGIInit            },
+         { "GhostscriptInferfaceTerm", (gpointer *)&pDev->pfnGITerm            }
+      };
+      bool           fFailure = FALSE;
+      int            i;
+
       pDev->ulPelSizeCorrection = 100;
 
       for (i = 0; i < sizeof (apszLibraryPaths)/sizeof (apszLibraryPaths[0]) && !pDev->hmodOmni; i++)
@@ -720,120 +739,96 @@
           if (pszDeviceLib)
           {
               sprintf (pszDeviceLib, "%s%s", apszLibraryPaths[i], cOmnilib);
+
               pDev->hmodOmni = g_module_open (pszDeviceLib, (GModuleFlags)0);
+
+              if (fDebugOutput) fprintf (stderr, "SetupDevice: Trying to load %s = 0x%08X\n", pszDeviceLib, (int)pDev->hmodOmni);
           }
           gs_free (pszDeviceLib, strlen (pszDeviceLib) + 1, 1, "Devicestring");
       }
 
       if (!pDev->hmodOmni)
       {
-         // Failure!
+         GModule *pModule = 0;
+
+         /* Failure! */
          fprintf (stderr, "<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n\n");
          fprintf (stderr, "Error: Could not load libomni.so\n");
          if (fDebugOutput) fprintf (stderr, "@ line %d gomni.c\n", __LINE__);
 
-         // @TBD - why doesnt return_error(gs_error_Fatal) work?
-         //        If it is in, then we get the following:
-         //
-         // Unrecoverable error: rangecheck in .putdeviceprops
-         //
-         // Unexpected interpreter error -15.
-         // Error object: (1488)op_array(586)0x81bc858:.putdeviceprops
-         // Execution stack at 0x81b0940:
-         // 0x81c6c74: 0x0f oper --F---e-- 0x0000 0x08084fcc = %interp_exit
-         // 0x81c6c7c: 0x03 file --G-rxe-- 0x0001 0x081bd010
-         // 0x81c6c84: 0x0e null --F---e-- 0x0000 0x08086b94
-         // 0x81c6c8c: 0x0b int  --F------ 0x01ac 0x00000008 = 8
-         // 0x81c6c94: 0x0b int  --F------ 0x0007 0x00000004 = 4
-         // 0x81c6c9c: 0x0f oper --F---e-- 0x0000 0x08086b80 = %oparray_pop
-         // 0x81c6ca4: 0x05 mpry --G-rxe-- 0x0002 0x0821032c
-         // 0x81c6cac: 0x0e null --F---e-- 0x0000 0x08086b94
-         // 0x81c6cb4: 0x0b int  --F------ 0x0001 0x00000008 = 8
-         // 0x81c6cbc: 0x0b int  --F------ 0x0000 0x00000004 = 4
-         // 0x81c6cc4: 0x0f oper --F---e-- 0x0000 0x08086b80 = %oparray_pop
-         // 0x81c6ccc: 0x05 mpry --G-rxe-- 0x0039 0x08210dae
-         // Dictionary stack at 0x81b0a00:
-         // 0x81c74a4: 0x02 dict --Gwrx--- 0x081b 0x081b947c
-         // 0x81c74ac: 0x02 dict --Gwrx--- 0x081c 0x0821d0a8
-         // 0x81c74b4: 0x02 dict --Lwrx--- 0x4000 0x081c1388
-         // 0x81c74bc: 0x02 dict --Gwrx--- 0x081b 0x081b947c
+         for (i = 0; i < sizeof (apszLibraryPaths)/sizeof (apszLibraryPaths[0]) && !pDev->hmodOmni; i++)
+         {
+             pszDeviceLib = (char *)gs_malloc (1,
+                                               strlen (cOmnilib)
+                                               + strlen (apszLibraryPaths[i])
+                                               + 1,
+                                               "Devicestring");
+             if (pszDeviceLib)
+             {
+                 sprintf (pszDeviceLib, "%s%s", apszLibraryPaths[i], cOmnilib);
+
+                 pModule = g_module_open (pszDeviceLib, (GModuleFlags)0);
+
+                 if (!pModule)
+                 {
+                    fprintf (stderr, "Error: Loading \"%s\" returns \"%s\"\n", pszDeviceLib, g_module_error ());
+                 }
+                 else
+                 {
+                    g_module_close (pModule);
+                 }
+             }
+             gs_free (pszDeviceLib, strlen (pszDeviceLib) + 1, 1, "Devicestring");
+         }
+
          return 1;
       }
 
-      g_module_symbol (pDev->hmodOmni, "GetPrintModeInfo", (gpointer *)&pDev->pfnGetPrintModeInfo);
-
-      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (GetPrintModeInfo) = 0x%08x\n", (int)pDev->pfnGetPrintModeInfo);
-
-      g_module_symbol (pDev->hmodOmni, "GetResolutionInfo", (gpointer *)&pDev->pfnGetResolutionInfo);
-
-      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (GetResolutionInfo) = 0x%08x\n", (int)pDev->pfnGetResolutionInfo);
-
-      g_module_symbol (pDev->hmodOmni, "GetMarginInfo", (gpointer *)&pDev->pfnGetMarginInfo);
-
-      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (GetMarginInfo) = 0x%08x\n", (int)pDev->pfnGetMarginInfo);
-
-      g_module_symbol (pDev->hmodOmni, "BeginJob", (gpointer *)&pDev->pfnBeginJob);
-
-      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (BeginJob) = 0x%08x\n", (int)pDev->pfnBeginJob);
-
-      g_module_symbol (pDev->hmodOmni, "NewFrame", (gpointer *)&pDev->pfnNewFrame);
-
-      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (NewFrame) = 0x%08x\n", (int)pDev->pfnNewFrame);
-
-      g_module_symbol (pDev->hmodOmni, "EndJob", (gpointer *)&pDev->pfnEndJob);
-
-      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (EndJob) = 0x%08x\n", (int)pDev->pfnEndJob);
-
-      g_module_symbol (pDev->hmodOmni, "Rasterize", (gpointer *)&pDev->pfnRasterize);
-
-      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (Rasterize) = 0x%08x\n", (int)pDev->pfnRasterize);
-
-      g_module_symbol (pDev->hmodOmni, "CreateDevice", (gpointer *)&pDev->pfnCreateDevice);
-
-      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (CreateDevice) = 0x%08x\n", (int)pDev->pfnCreateDevice);
-
-      g_module_symbol (pDev->hmodOmni, "DeleteDevice", (gpointer *)&pDev->pfnDeleteDevice);
-
-      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (DeleteDevice) = 0x%08x\n", (int)pDev->pfnDeleteDevice);
-
-      g_module_symbol (pDev->hmodOmni, "DiffusionDither", (gpointer *)&pDev->pfnMonoDither);
-
-      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (DiffusionDither) = 0x%08x\n", (int)pDev->pfnMonoDither);
+      for (i = 0; i < (int)dimof (aeplEntryPoints); i++)
+      {
+         g_module_symbol (pDev->hmodOmni,
+                          aeplEntryPoints[i].pszEntryPoint,
+                          aeplEntryPoints[i].pfnEntryPoint);
 
-      g_module_symbol (pDev->hmodOmni, "GhostscriptInferfaceInit", (gpointer *)&pDev->pfnGIInit);
+         if (!*aeplEntryPoints[i].pfnEntryPoint)
+         {
+            if (!fFailure)
+            {
+               fprintf (stderr, "\n<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n\n");
+            }
 
-      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (GhostscriptInferfaceInit) = 0x%08x\n", (int)pDev->pfnGIInit);
+            fprintf (stderr, "Error: Could not load required entry point \"%s\" from libomni.so\n", aeplEntryPoints[i].pszEntryPoint);
 
-      g_module_symbol (pDev->hmodOmni, "GhostscriptInferfaceTerm", (gpointer *)&pDev->pfnGITerm);
+            fFailure = TRUE;
+         }
 
-      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (GhostscriptInferfaceTerm) = 0x%08x\n", (int)pDev->pfnGITerm);
+         if (fDebugOutput)
+            fprintf (stderr,
+                     "SetupDevice: g_module_symbol (%s) = 0x%08x\n",
+                     aeplEntryPoints[i].pszEntryPoint,
+                     (int)*aeplEntryPoints[i].pfnEntryPoint);
+      }
 
       if (  !pDev->pfnCreateDevice
-//       || !pDev->pfnDeleteDevice
          || !pDev->pfnBeginJob
-         || !pDev->pfnNewFrame            //@@04162001
+         || !pDev->pfnNewFrame
          || !pDev->pfnEndJob
          || !pDev->pfnRasterize
          || !pDev->pfnGetPrintModeInfo
          || !pDev->pfnGetResolutionInfo
          || !pDev->pfnGetMarginInfo
-         || !pDev->pfnMonoDither          //@@04162001
+         || !pDev->pfnMonoDither
          )
       {
-         // Failure!
-         fprintf (stderr, "\n<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n\n");
-         fprintf (stderr, "Error: Could not load required entry points from libomni.so\n");
-         if (fDebugOutput) fprintf (stderr, "@ line %d gomni.c\n", __LINE__);
-
+         /* Failure! */
          g_module_close (pDev->hmodOmni);
          pDev->hmodOmni = 0;
 
-         // @TBD - why doesnt return_error(gs_error_Fatal) work? (see above)
          return 1;
       }
    }
 
-   // device name in structure
+   /* device name in structure*/
    if (!pDev->pcoreOmni->cDeviceName[0])
    {
       memset (&fname, 0, sizeof (fname));
@@ -849,7 +844,7 @@
       }
    }
 
-   // set debugging file name
+   /* set debugging file name */
    if (!pDev->pcoreOmni->cDebugFile[0])
    {
       memset (&fname, 0, sizeof (fname));
@@ -865,7 +860,7 @@
       }
    }
 
-   // set Async option
+   /* set Async option */
    if (!pDev->cAsyncOpt[0])
    {
       memset (&fname, 0, sizeof (fname));
@@ -913,7 +908,7 @@
       }
    }
 
-   // Set user options for monodither by GS
+   /* Set user options for monodither by GS */
    if (!pDev->cMonoDither[0])
    {
       memset (&fname, 0, sizeof (fname));
@@ -940,7 +935,7 @@
       }
    }
 
-   // Set user options for client / server function
+   /* Set user options for client / server function */
    if (!pDev->pcoreOmni->cServer[0])
    {
       memset (&fname, 0, sizeof (fname));
@@ -982,7 +977,7 @@
       && pDev->iSetup != 1
       )
    {
-      // create a device based on the user supplied inputs
+      /* create a device based on the user supplied inputs */
       if (fDebugOutput) fprintf(stderr, "setting following options on CreateDevice\n");
       if (fDebugOutput) fprintf(stderr, "DeviceName = %s\n", pDev->pcoreOmni->cDeviceName );
       if (fDebugOutput) fprintf(stderr, "pszJobOptions = %s\n", pDev->pcoreOmni->pszJobOptions);
@@ -1018,7 +1013,36 @@
 
          if (!pModule)
          {
-            fprintf (stderr, "Unable to open <<%s>>.", cDialogName);
+            /* Print the error messages! */
+            fprintf (stderr, "\n<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n\n");
+            fprintf (stderr, "Error: Could not load %s\n", cDialogName);
+
+            for (i = 0; i < sizeof (apszLibraryPaths)/sizeof (apszLibraryPaths[0]) && !pModule; i++)
+            {
+               pszDeviceLib = (char *)gs_malloc (1,
+                                                 strlen (cDialogName)
+                                                 + strlen (apszLibraryPaths[i])
+                                                 + 1,
+                                                 "Devicestring");
+               pszDeviceLib[0] = '\0';
+
+               if (pszDeviceLib)
+               {
+                   sprintf (pszDeviceLib, "%s%s", apszLibraryPaths[i], cDialogName);
+
+                   pModule = g_module_open (pszDeviceLib, (GModuleFlags)0);
+
+                   if (!pModule)
+                   {
+                      fprintf (stderr, "Error: Loading \"%s\" returns \"%s\"\n", pszDeviceLib, g_module_error ());
+                   }
+                   else
+                   {
+                      g_module_close (pModule);
+                   }
+               }
+               gs_free (pszDeviceLib, strlen (pszDeviceLib) + 1, 1, "Devicestring");
+            }
          }
          else
          {
@@ -1053,6 +1077,12 @@
                   if (fDebugOutput) fprintf (stderr, "Freeing Dialog Memory\n");
                }
             }
+            else
+            {
+               fprintf (stderr, "Error: Unable to find <<GetOmniJobProperties>> in <<%s>>.\n", cDialogName);
+            }
+
+            g_module_close (pModule);
          }
       }
 
@@ -1061,7 +1091,7 @@
          pDev->pcoreOmni->bPDCDevice = true;
       }
 
-      // get the omni version in case we need it
+      /* get the omni version in case we need it */
       if (pDev->pfnGIInit)
       {
          pDev->pfnGIInit ((void*)pDev->pcoreOmni);
@@ -1086,7 +1116,7 @@
          fprintf (stderr, "Error: Unable create a omni device\n");
          if (fDebugOutput) fprintf (stderr, "@ line %d gomni.c\n", __LINE__);
 
-         return_error (gs_error_Fatal);  // fail if no device was created
+         return_error (gs_error_Fatal);  /* fail if no device was created */
       }
 
       if (fDebugOutput) fprintf (stderr, "Device = %08X\n", (unsigned int)pDev->pcoreOmni->pDevice);
@@ -1101,7 +1131,7 @@
 
       if (bRet)
       {
-         // turn off Ghostscript mono if we are not in mono mode
+         /* turn off Ghostscript mono if we are not in mono mode */
          if (  (prtMode.iBitCount > 1)
             && pDev->iGSMono
             )
@@ -1110,10 +1140,10 @@
             pDev->iGSMono = 0;
          }
       }
-                         //** this routine is called multiple times
-      pDev->iSetup = 1;  //** don't go setting up new devices
+                         /* this routine is called multiple times */
+      pDev->iSetup = 1;  /* don't go setting up new devices */
 
-      // get the hardware resolution information
+      /* get the hardware resolution information */
 
       bRet = pDev->pfnGetResolutionInfo ((void*)pDev->pCallPtr, &hwRes);
 
@@ -1126,7 +1156,7 @@
           return_error (gs_error_Fatal);
       }
 
-      // get the hardware page margins information
+      /* get the hardware page margins information */
 
       bRet = pDev->pfnGetMarginInfo ((void*)pDev->pCallPtr, &hwMargins);
 
@@ -1151,57 +1181,57 @@
        *  We have to let GS know about our page and resolution parameters
        */
 
-      // setup the width and height of the page
+      /* setup the width and height of the page */
       prgxdev->width  = (int)hwMargins.fxWidth;
       prgxdev->height = (int)hwMargins.fyHeight;
       prgxdev->MediaSize[1] = (hwMargins.fyHeight/(float)hwRes.yRes)*72.0;
       prgxdev->MediaSize[0] = (hwMargins.fxWidth/(float)hwRes.xRes)*72.0;
 
-      // does not seem like pels works correctly for margins so lets set the margins
-      // using points instead
+      /* does not seem like pels works correctly for margins so lets set the margins */
+      /* using points instead */
 
-      // left margin
-      prgxdev->HWMargins[0] = (float)hwMargins.fLeftClip/25400.0 *72.0;           //@@05092001A
+      /* left margin */
+      prgxdev->HWMargins[0] = (float)hwMargins.fLeftClip/25400.0 *72.0;
 
-      // bottom margin
-      prgxdev->HWMargins[1] = (float)hwMargins.fBottomClip/25400.0 *72.0;         //@@05092001A
+      /* bottom margin */
+      prgxdev->HWMargins[1] = (float)hwMargins.fBottomClip/25400.0 *72.0;
 
-      // right margin
-      prgxdev->HWMargins[2] = (float)hwMargins.fRightClip/25400.0 *72.0;          //@@05092001A
+      /* right margin */
+      prgxdev->HWMargins[2] = (float)hwMargins.fRightClip/25400.0 *72.0;
 
-      // top margin
-      prgxdev->HWMargins[3] = (float)hwMargins.fTopClip/25400.0 *72.0;            //@@05092001A
+      /* top margin */
+      prgxdev->HWMargins[3] = (float)hwMargins.fTopClip/25400.0 *72.0;
 
-      // set x resolution
+      /* set x resolution */
       prgxdev->HWResolution[0] = (float)hwRes.xRes;
 
-      // set y resolution
+      /* set y resolution */
       prgxdev->HWResolution[1] = (float)hwRes.yRes;
 
-      prgxdev->pDev->iVertDots = (float)hwRes.fScanDots;  // fill in the scan line
+      prgxdev->pDev->iVertDots = (float)hwRes.fScanDots;  /* fill in the scan line */
 
-      if (fDebugOutput) fprintf (stderr, "left margin pts   = %f \n", prgxdev->HWMargins[0]);    //@@05092001A
-      if (fDebugOutput) fprintf (stderr, "bottom margin pts = %f \n", prgxdev->HWMargins[1]);    //@@05092001A
-      if (fDebugOutput) fprintf (stderr, "right margin pts  = %f \n", prgxdev->HWMargins[2]);    //@@05092001A
-      if (fDebugOutput) fprintf (stderr, "top margin pts    = %f \n", prgxdev->HWMargins[3]);    //@@05092001A
+      if (fDebugOutput) fprintf (stderr, "left margin pts   = %f \n", prgxdev->HWMargins[0]);
+      if (fDebugOutput) fprintf (stderr, "bottom margin pts = %f \n", prgxdev->HWMargins[1]);
+      if (fDebugOutput) fprintf (stderr, "right margin pts  = %f \n", prgxdev->HWMargins[2]);
+      if (fDebugOutput) fprintf (stderr, "top margin pts    = %f \n", prgxdev->HWMargins[3]);
 
       if (!pDev->iGSMono)
       {
-         // 1,1,1,0,2,0       - mono  //@@04252001
-         // 3, 24,255,255,5,5 - color //@@04252001
-         if (fDebugOutput) fprintf (stderr, "depth = %d \n", prgxdev->color_info.depth              );   //@@04252001
-         if (fDebugOutput) fprintf (stderr, "num_comp = %d \n", prgxdev->color_info.num_components  );   //@@04252001
-         if (fDebugOutput) fprintf (stderr, "max_gray = %d \n", prgxdev->color_info.max_gray        );   //@@04252001
-         if (fDebugOutput) fprintf (stderr, "max_color = %d \n", prgxdev->color_info.max_color      );   //@@04252001
-         if (fDebugOutput) fprintf (stderr, "dither_grays = %d \n", prgxdev->color_info.dither_grays   );//@@04252001
-         if (fDebugOutput) fprintf (stderr, "dither_colors = %d \n", prgxdev->color_info.dither_colors );//@@04252001
-                                                                                                        //@@04252001
-         prgxdev->color_info.depth          = 24;                                                      //@@04252001
-         prgxdev->color_info.num_components = 3;                                                       //@@04252001
-         prgxdev->color_info.max_gray       = 255;                                                     //@@04252001
-         prgxdev->color_info.max_color      = 255;                                                     //@@04252001
-         prgxdev->color_info.dither_grays   = 5;                                                       //@@04252001
-         prgxdev->color_info.dither_colors  = 5;                                                       //@@04252001
+         /* 1,1,1,0,2,0       - mono   */
+         /* 3, 24,255,255,5,5 - color  */
+         if (fDebugOutput) fprintf (stderr, "depth = %d \n", prgxdev->color_info.depth              );
+         if (fDebugOutput) fprintf (stderr, "num_comp = %d \n", prgxdev->color_info.num_components  );
+         if (fDebugOutput) fprintf (stderr, "max_gray = %d \n", prgxdev->color_info.max_gray        );
+         if (fDebugOutput) fprintf (stderr, "max_color = %d \n", prgxdev->color_info.max_color      );
+         if (fDebugOutput) fprintf (stderr, "dither_grays = %d \n", prgxdev->color_info.dither_grays   );
+         if (fDebugOutput) fprintf (stderr, "dither_colors = %d \n", prgxdev->color_info.dither_colors );
+
+         prgxdev->color_info.depth          = 24;
+         prgxdev->color_info.num_components = 3;
+         prgxdev->color_info.max_gray       = 255;
+         prgxdev->color_info.max_color      = 255;
+         prgxdev->color_info.dither_grays   = 5;
+         prgxdev->color_info.dither_colors  = 5;
       }
    }
 
@@ -1209,7 +1239,7 @@
 
    if (fDebugOutput) fprintf (stderr, "SetupDevice returning %d\n", iReturnCode);
 
-   return iReturnCode;  // likely not be a failure
+   return iReturnCode;  /* likely not be a failure */
 }
 
 private int
@@ -1233,13 +1263,13 @@
    /*
     * The following variables are uses for outputting the bitmap information
     */
-   uint                   uiBytesPerLine   = uiLineSize + (-uiLineSize & 3);  //actual raster line size used for row
+   uint                   uiBytesPerLine   = uiLineSize + (-uiLineSize & 3);  /*actual raster line size used for row */
 
-   byte                  *pBitmapMem       = NULL;   // bitmap memory for the bitmap band
+   byte                  *pBitmapMem       = NULL;   /* bitmap memory for the bitmap band */
    bool                   bRet;
    RECTL                  rectPageLocation;
    SIZEL                  sizelPage;
-   ULONG                  ulBandLength;              // number of scan-lines to match the memory threshold for a band
+   ULONG                  ulBandLength;              /* number of scan-lines to match the memory threshold for a band */
    int                    iBytesToAlloc;
 
    int                    iYBand;
@@ -1249,7 +1279,7 @@
    byte                  *pGSData          = 0;
    byte                  *raster_data;
 
-   // MONO
+   /* MONO */
    byte                  *pMonoData        = NULL;
    DIFFUSIONDITHERINFO    DiffInfo;
    byte                  *pBuffer          = NULL;
@@ -1257,9 +1287,9 @@
    POINTL                 ptlBounds;
    POINTL                 ptlTrgBounds;
 
-   PRINTMODE              prtMode;                   // definition of printed output Bpp ..
+   PRINTMODE              prtMode;                   /* definition of printed output Bpp .. */
 
-   // Get things setup to call into the driver code
+   /* Get things setup to call into the driver code */
    BITMAPINFO2           *pbmi;
 
    PDEVSTRUCT             pDev             = pasyncDev->pDev;
@@ -1281,13 +1311,13 @@
    }
 
    pDev->iPage++;
-   pDev->iPageNumber++;  //keep track of the page @@04162001
+   pDev->iPageNumber++;  /*keep track of the page @@04162001 */
 
    bRet = pDev->pfnGetPrintModeInfo ((void*)pasyncDev->pDev->pCallPtr, &prtMode);
 
    iNumColors = 1 << prtMode.iBitCount;
 
-   // Allocate a full bitmapinfo2 and bitmap header message
+   /* Allocate a full bitmapinfo2 and bitmap header message */
    iBytesToAlloc = sizeof (BITMAPINFO2);
    if (256 >= iNumColors)
    {
@@ -1306,7 +1336,7 @@
 
    pbmi->cbFix = sizeof(BITMAPINFO2); /* Length of fixed portion of structure?? */
 
-   if (256 >= iNumColors)  // must be 16 or 24 bit
+   if (256 >= iNumColors)  /* must be 16 or 24 bit */
    {
       if (iNumColors == 2)
       {
@@ -1317,48 +1347,48 @@
          DiffInfo.ulType      = GDM_MATRIX_DITHER;
          DiffInfo.fOptions    =  0;
          DiffInfo.ulIntensity = 80;
-         DiffInfo.bRedWt      = 30; //25
-         DiffInfo.bGreenWt    = 50; //60
-         DiffInfo.bBlueWt     = 20; //15
+         DiffInfo.bRedWt      = 30; /*25 */
+         DiffInfo.bGreenWt    = 50; /*60 */
+         DiffInfo.bBlueWt     = 20; /*15 */
          DiffInfo.bPad        =  0;
 
-         if (!pDev->iGSMono)                                       //@@04252001
-         {                                                         //@@04252001
-            pbmi->argbColor[0].bBlue  = 0xFF;  // background       //@@04252001
-            pbmi->argbColor[0].bRed   = 0xFF;                      //@@04252001
-            pbmi->argbColor[0].bGreen = 0xFF;                      //@@04252001
-            pbmi->argbColor[1].bBlue  = 0x00;  // foreground       //@@04252001
-            pbmi->argbColor[1].bRed   = 0x00;                      //@@04252001
-            pbmi->argbColor[1].bGreen = 0x00;                      //@@04252001
-         }                                                         //@@04252001
-         else                                                      //@@04252001
-         {                                                         //@@04252001
-            pbmi->argbColor[1].bBlue  = 0xFF;  // background       //@@04252001
-            pbmi->argbColor[1].bRed   = 0xFF;                      //@@04252001
-            pbmi->argbColor[1].bGreen = 0xFF;                      //@@04252001
-            pbmi->argbColor[0].bBlue  = 0x00;  // foreground       //@@04252001
-            pbmi->argbColor[0].bRed   = 0x00;                      //@@04252001
-            pbmi->argbColor[0].bGreen = 0x00;                      //@@04252001
-         }                                                         //@@04252001
+         if (!pDev->iGSMono)
+         {
+            pbmi->argbColor[0].bBlue  = 0xFF;  /* background        */
+            pbmi->argbColor[0].bRed   = 0xFF;
+            pbmi->argbColor[0].bGreen = 0xFF;
+            pbmi->argbColor[1].bBlue  = 0x00;  /* foreground        */
+            pbmi->argbColor[1].bRed   = 0x00;
+            pbmi->argbColor[1].bGreen = 0x00;
+         }
+         else
+         {
+            pbmi->argbColor[1].bBlue  = 0xFF;  /* background        */
+            pbmi->argbColor[1].bRed   = 0xFF;
+            pbmi->argbColor[1].bGreen = 0xFF;
+            pbmi->argbColor[0].bBlue  = 0x00;  /* foreground        */
+            pbmi->argbColor[0].bRed   = 0x00;
+            pbmi->argbColor[0].bGreen = 0x00;
+         }
 
-         ImageInfo.pptlSrc             = &ptlBounds;       // rectangle extents
-         ImageInfo.pptlDst             = &ptlTrgBounds;    // rectangle extents
+         ImageInfo.pptlSrc             = &ptlBounds;       /* rectangle extents */
+         ImageInfo.pptlDst             = &ptlTrgBounds;    /* rectangle extents */
          ImageInfo.ulSrcBpp            = 24;
-         ImageInfo.ulSrcBytesPerLine   = uiBytesPerLine;   // src bytes per line
+         ImageInfo.ulSrcBytesPerLine   = uiBytesPerLine;   /* src bytes per line */
          ImageInfo.ulcSrcClrs          = 0;
          ImageInfo.ulSrcClrType        = 0;
-         ImageInfo.pargb2Src           = 0;                // if srcBPP != 24
+         ImageInfo.pargb2Src           = 0;                /* if srcBPP != 24 */
          ImageInfo.ulTrgBpp            = 1;
          ImageInfo.ulTrgBytesPerLine   = pasyncDev->width + (-pasyncDev->width & 31);
          ImageInfo.ulTrgBytesPerLine  /= 8;
          ImageInfo.ulcTrgClrs          = 2;
          ImageInfo.ulTrgClrType        = 0;
          ImageInfo.pargb2Trg           = NULL;
-         ImageInfo.ulOptions           = 0;            // options
+         ImageInfo.ulOptions           = 0;            /* options */
          ImageInfo.ulPelSizeCorrection = pDev->ulPelSizeCorrection;
 
-         ptlBounds.x = pasyncDev->width;             // Bounding rectangle for input bitmap
-         ptlTrgBounds.x = pasyncDev->width;          // Bounding rectangle for output bitmap
+         ptlBounds.x = pasyncDev->width;             /* Bounding rectangle for input bitmap */
+         ptlTrgBounds.x = pasyncDev->width;          /* Bounding rectangle for output bitmap */
       }
       else
       {
@@ -1412,14 +1442,13 @@
       fseek (prn_stream, 0L, SEEK_SET);
    }
 
-   // need to calculate the correct bandsize needed for the device
+   /* need to calculate the correct bandsize needed for the device */
    ulBandLength = FindBandSize (pasyncDev->height,
                                 pasyncDev->width,
-////////////////////////////////pbmi->cBitCount,
-                                24,                         // always use 24 bits for source bitmap
+                                24,                         /* always use 24 bits for source bitmap */
                                 pbmi->cPlanes,
                                 pasyncDev->pDev->iVertDots,
-                                8000*1024);                 //eight meg buffer
+                                8000*1024);                 /*eight meg buffer */
 
    pBitmapMem = (byte *) gs_malloc (1, uiBytesPerLine * ulBandLength, "Bitmap Memory");
 
@@ -1432,7 +1461,7 @@
       return_error (gs_error_VMerror);
    }
 
-   // is the band bigger than the page ?
+   /* is the band bigger than the page ? */
 
    sizelPage.cx = pasyncDev->width;
    sizelPage.cy = pasyncDev->height;
@@ -1441,7 +1470,7 @@
 
    if (pBitmapMem)
    {
-      memset (pBitmapMem, 0xFF, uiBytesPerLine * ulBandLength ); // memset the memory to white? maybe zero
+      memset (pBitmapMem, 0xFF, uiBytesPerLine * ulBandLength ); /* memset the memory to white? maybe zero */
    }
    else
    {
@@ -1452,12 +1481,12 @@
       return_error (gs_error_VMerror);
    }
 
-   // Do initial setup for Rasterize for dithering work on the page.
+   /* Do initial setup for Rasterize for dithering work on the page. */
 
    rectPageLocation.xLeft  = 0;
    rectPageLocation.xRight = pasyncDev->width;
 
-   //@@04162001
+
    if (pDev->iPageNumber == 1)
    {
       pDev->pcoreOmni->pfpOut = prn_stream;
@@ -1469,17 +1498,17 @@
       pDev->pfnNewFrame ((void*)pasyncDev->pDev->pCallPtr);
    }
 
-// rectPageLocation.yTop = rectPageLocation.yBottom  = 0;  @@10172000
-   rectPageLocation.yTop = pasyncDev->height-1;       // @@10172000
+/* rectPageLocation.yTop = rectPageLocation.yBottom  = 0;  @@10172000 */
+   rectPageLocation.yTop = pasyncDev->height-1;       /* @@10172000 */
 
    /*
     *    Banding Implementation based on bandsize - need to put bits in place so that we can
     *    tell if this is a top to down or bottom to top printer.
     */
    {
-      //BEGIN BLOCK for Banding code
+      /*BEGIN BLOCK for Banding code */
 
-//    int iCurTop = 0, iCurBot = 0;  @@10172000
+/*    int iCurTop = 0, iCurBot = 0;  @@10172000 */
 
       /*
        *  Since this band needs to be flipped, we need to get a pointer to the top of memory
@@ -1492,16 +1521,16 @@
 
       iYBand = 0;
 
-      // Call DiffusionDither to setup pBuffer - quick in and out  @@04062001
-      if (!pDev->iGSMono)          //@@04252001
+      /* Call DiffusionDither to setup pBuffer - quick in and out  @@04062001 */
+      if (!pDev->iGSMono)
          pDev->pfnMonoDither (&DiffInfo,
                               &ImageInfo,
                               &pBuffer,
                               (unsigned long)GDM_DITHER_BEGIN);
 
-      // Go through the bitmap that we have been given
+      /* Go through the bitmap that we have been given */
       for (y = pasyncDev->height - 1; y >= 0; y--)
-      {                                   //@@10312000
+      {
          if (  (iYBand < ulBandLength)
             && ((code = dev_proc(pgx_dev, get_bits)(pgx_dev, pasyncDev->height - 1 - y, pGSData, &raster_data)) >= 0)
             && (y != 0)
@@ -1509,28 +1538,28 @@
          {
             memcpy (pBitmapTop - (iYBand  * uiBytesPerLine), raster_data, uiBytesPerLine);
 
-            iYBand++;  // keep track of lines in the band
+            iYBand++;  /* keep track of lines in the band */
          }
          else
          {
             if (  (code < 0)
                && (y > 0)
-               )             // add back in the line we failed to get if an error was returned from get_bits
+               )             /* add back in the line we failed to get if an error was returned from get_bits */
             {
-               if (iYBand != ulBandLength)                                                    //@@10252000
+               if (iYBand != ulBandLength)
                {
                   y++;
                   continue;
                }
             }
 
-            // we always decrement y when we come through here even if this is just a complete band
-            if (iYBand == ulBandLength)      //@@10312000
+            /* we always decrement y when we come through here even if this is just a complete band */
+            if (iYBand == ulBandLength)
                y++;
 
-            // we currently support 24bit or mono so if this is the mono case, allocate memory to be
-            // used for the gray-scaled bitmap buffer
-            if (!pDev->iGSMono)                    //@@04252001
+            /* we currently support 24bit or mono so if this is the mono case, allocate memory to be */
+            /* used for the gray-scaled bitmap buffer */
+            if (!pDev->iGSMono)
             {
                if (prtMode.iBitCount < 16)
                {
@@ -1549,29 +1578,28 @@
                      return_error (gs_error_VMerror);
                   }
 
-                  ImageInfo.pptlSrc->y = ImageInfo.pptlDst->y = iYBand;               // exclusive??
-                  ImageInfo.pbSrcBits  = pBitmapTop - ((iYBand-1) * uiBytesPerLine);  // pointer to src image data
-                  ImageInfo.pbTrgBits  = pMonoData;                                   // pointer to dst image data
+                  ImageInfo.pptlSrc->y = ImageInfo.pptlDst->y = iYBand;               /* exclusive?? */
+                  ImageInfo.pbSrcBits  = pBitmapTop - ((iYBand-1) * uiBytesPerLine);  /* pointer to src image data */
+                  ImageInfo.pbTrgBits  = pMonoData;                                   /* pointer to dst image data */
+
+                  /* Call DiffusionDither to generate a gray-scaled image from our 24bit bitmap */
 
-                  // Call DiffusionDither to generate a gray-scaled image from our 24bit bitmap
-                  //@@04062001
                   pDev->pfnMonoDither (&DiffInfo, &ImageInfo, &pBuffer, (unsigned long) 0);
                }
             }
 
             pbmi->cy = iYBand;
 
-            // set the page location to account for the new band size (cy)
+            /* set the page location to account for the new band size (cy) */
 
-////////////rectPageLocation.yTop = iCurTop + pbmi->cy;  @@10172000
-            rectPageLocation.yBottom  = rectPageLocation.yTop - pbmi->cy ; // @@10172000
+            rectPageLocation.yBottom  = rectPageLocation.yTop - pbmi->cy ; /* @@10172000 */
 
-            // If this in a mono device, we need to send the mono data to the device and
-            // not the color
+            /* If this in a mono device, we need to send the mono data to the device and */
+            /* not the color */
 
             if (  pMonoData
                && !pDev->iGSMono
-               ) //@@04252001
+               )
             {
                pDev->pfnRasterize ((void*)pasyncDev->pDev->pCallPtr,
                                    pMonoData,
@@ -1580,15 +1608,15 @@
                                    &rectPageLocation,
                                    BITBLT_BITMAP);
 
-               // We're done with the mono band
-               // now free up the mono buffer so we can get clean data buffer if more lines are to be
-               // gray-scaled
+               /* We're done with the mono band */
+               /* now free up the mono buffer so we can get clean data buffer if more lines are to be */
+               /* gray-scaled */
                gs_free ((char *)pMonoData, iYBand * ImageInfo.ulTrgBytesPerLine, 1, "Mono Memory");
 
                pMonoData = NULL;
             }
             else
-            {  // non-mono device -- Send the rgb bitmap to the dither and rasterize routines
+            {  /* non-mono device -- Send the rgb bitmap to the dither and rasterize routines */
                if (fDebugOutput) fprintf(stderr, "rendering band lines %d - %d w/%d \n", (int)rectPageLocation.yTop, (int)rectPageLocation.yBottom, iYBand);
 
                if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
@@ -1605,31 +1633,29 @@
                                    &sizelPage,
                                    &rectPageLocation,
                                    BITBLT_BITMAP);
-                                                       // memset the memory to white
+                                                       /* memset the memory to white */
                memset (pBitmapMem, 0xFF, uiBytesPerLine * ulBandLength);
             }
 
-            // implemented based on the number of lines sent to the
-            // printer and not based on the bandsize
-
-////////////rectPageLocation.yBottom = pbmi->cy + iCurBot; @@10172000
+            /*
+	     * implemented based on the number of lines sent to the
+             * printer and not based on the bandsize
+	     */
 
-            rectPageLocation.yTop -= iYBand;   // @@10172000
-////////////iCurBot =  rectPageLocation.yBottom;  @@10172000
-////////////iCurTop =  rectPageLocation.yTop;     @@10172000
+            rectPageLocation.yTop -= iYBand;
 
             iYBand = 0;
          }
-      } //@@04062001
+      }
 
-      if (!pDev->iGSMono)                                      //@@04252001
+      if (!pDev->iGSMono)
          pDev->pfnMonoDither (&DiffInfo,
                               &ImageInfo,
                               &pBuffer,
                               (unsigned long)GDM_DITHER_END);
 
       pBuffer = NULL;
-   } //END BLOCK
+   } /*END BLOCK*/
 
 done:
 
@@ -1988,24 +2014,24 @@
       ulModulus = 1;
    }
 
-   // figure out how much memory is needed fore each line
+   /* figure out how much memory is needed fore each line */
    ulSizeScanLine = ((ulBitsPerPel*ulXWidth+31)/32)*ulNumPlanes*4;
 
-   // Figure out how much memory is needed for the page
+   /* Figure out how much memory is needed for the page */
    ulMemoryNeeded = ulYHeight * ulSizeScanLine;
 
-   // How many lines can fit in the size given?
+   /* How many lines can fit in the size given? */
    ulNumLinesFit = ulMemoryLimit / ulSizeScanLine;
 
    if (0 == ulNumLinesFit)
-      // Minimum of 1 scan line
+      /* Minimum of 1 scan line */
       ulNumLinesFit = 1;
 
    if (ulNumLinesFit <= ulModulus)
-      // Not enough lines... Promote it to a modulus.
+      /* Not enough lines... Promote it to a modulus. */
       ulNumLinesFit = ulModulus;
    else
-      // Bump down the number of lines so that it is a modulus.
+      /* Bump down the number of lines so that it is a modulus. */
       ulNumLinesFit -= ulNumLinesFit % ulModulus;
 
    if ((ulYHeight % ulNumLinesFit) * 100 / ulYHeight <= 15)
@@ -2019,5 +2045,5 @@
       ulNumLinesFit += usBumpUp;
    }
 
-   return ulNumLinesFit ;  // return the number of lines we want for the band
+   return ulNumLinesFit ;  /* return the number of lines we want for the band */
 }
