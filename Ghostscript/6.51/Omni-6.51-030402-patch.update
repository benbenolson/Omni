diff -ur src/defs.h ghostscript-6.51-030402/src/defs.h
--- src/defs.h	Tue Mar  5 10:00:39 2002
+++ src/defs.h	Tue Mar  5 10:07:37 2002
@@ -1,5 +1,15 @@
-
-
+/*******************************************************************************/
+/*                                                                             */
+/* FILE:  defs.h                                                               */
+/*                                                                             */
+/*  Header file to satisfy defines for gomni.c                                .*/
+/*                                                                             */
+/*                                                                             */
+/* Created: 03-21-2000                                                         */
+/*                                                                             */
+/*                                                                             */
+/*                                                                             */
+/*******************************************************************************/
 /*
  *   IBM Omni driver
  *   Copyright (c) International Business Machines Corp., 2000
@@ -22,18 +32,6 @@
  *   Enterprises
  *
  */
-/*******************************************************************************/
-/*                                                                             */
-/* FILE:  defs.h                                                               */
-/*                                                                             */
-/*  Header file to satisfy defines for gomni.c                                .*/
-/*                                                                             */
-/*                                                                             */
-/* Created: 03-21-2000                                                         */
-/*                                                                             */
-/*                                                                             */
-/*                                                                             */
-/*******************************************************************************/
 
 #define APIENTRY
 #define LOCAL
diff -ur src/gomni.c ghostscript-6.51-030402/src/gomni.c
--- src/gomni.c	Tue Mar  5 10:00:39 2002
+++ src/gomni.c	Tue Mar  5 10:07:37 2002
@@ -1,4 +1,4 @@
-/*  
+/*
  *   IBM Omni driver
  *   Copyright (c) International Business Machines Corp., 2000
  *
@@ -111,10 +111,8 @@
 const static int fDebugOutput = 0;
 
 #define DEVICES_DEFINED
-#define ORIENTATION_STRING "orientation=ORIENTATION_PORTRAIT"
 
-typedef struct _HWMAR
-{
+typedef struct _HWMAR {
   float fLeftClip;
   float fBottomClip;
   float fRightClip;
@@ -123,110 +121,88 @@
   float fyHeight;
 } HWMARGINS;
 
-typedef struct _HWRES
-{
+typedef struct _HWRES {
   float xRes;
   float yRes;
   float fScanDots;  // number of dots in scan line
 } HWRESOLUTION;
 
-typedef struct _PRTMODE
-{
+typedef struct _PRTMODE {
   int iBitCount;
   int iPlanes;
 } PRINTMODE;
 
-long DiffusionDither(PDDI pdi, PIMAGEINFO pimg_infos, PBYTE *pBuffer, ULONG ulFlgs);
+long DiffusionDither (PDDI pdi, PIMAGEINFO pimg_infos, PBYTE *pBuffer, ULONG ulFlgs);
 
 /*
  *   Prototypes for routines that we will be calling into the core Omni code
  *   to resolve
  */
+typedef bool   (*PFNGIINIT)            (void         *pDev);
+typedef bool   (*PFNGITERM)            (void         *pDev);
 typedef bool   (*PFNGETPRINTMODEINFO)  (void         *pDev,
                                         PRINTMODE    *pPrtMode);
 typedef bool   (*PFNGETRESOLUTIONINFO) (void         *pDev,
                                         HWRESOLUTION *hwRes);
 typedef bool   (*PFNGETMARGININFO)     (void         *pDev,
                                         HWMARGINS    *hwMargins);
-typedef bool   (*PFNGETVERSION)        (void         *pDev,
-                                        char         *OmniVersion);
-
-typedef void   (* PFNBEGINJOB)         (void *pOmni,
-                                        FILE *pFile); 
-//                                        char  *pszDeviceName, 
-//                                        char  *pszJobProperties);
-
+typedef void   (*PFNBEGINJOB)          (void         *pOmni,
+                                        FILE         *pfpOut);
 typedef void   (*PFNNEWFRAME)          (void         *pDev); //@@04162001
-
-typedef void   (*PFNENDJOB)            (void         *pDev,
-                                        void         *pOutputObject);
+typedef void   (*PFNENDJOB)            (void         *pDev);
 typedef void   (*PFNRASTERIZE)         (void         *pcoreOmni,
                                         PBYTE         pbBits,
                                         PBITMAPINFO2  pbmi,
                                         PSIZEL        psizelPage,
                                         PRECTL        prectlPageLocation,
                                         BITBLT_TYPE   eType);
-typedef void * (*PFNCREATEDEVICE)      (char         *pszDeviceName,
-                                        void         *pOutputObject,
-                                        GModule     **hmodDevice,
-                                        void         *pszDebugFile,
-                                        char         *pszOptions,
-                                        int           iUseClient,   //@@05092001
-                                        FILE         *file);        //@@05092001
-
+typedef void * (*PFNCREATEDEVICE)      (void         *pOmni,
+                                        void        **vhDevice,
+                                        int           iUsePDC);
 typedef long   (*PFNMONODITHER)        (PDDI          pdi,           //@@04062001
                                         PIMAGEINFO    pimg_infos,
                                         PBYTE        *pBuffer,
                                         ULONG         ulFlgs);
 
-ULONG FindBandSize(ULONG ulYHeight, ULONG ulXWidth, ULONG ulBitsPerPel, ULONG ulNumPlanes,
-                            ULONG ulModulus, ULONG ulMemoryLimit);
+ULONG         FindBandSize             (ULONG ulYHeight,
+                                        ULONG ulXWidth,
+                                        ULONG ulBitsPerPel,
+                                        ULONG ulNumPlanes,
+                                        ULONG ulModulus,
+                                        ULONG ulMemoryLimit);
+
+typedef int (*PFNGETOMNIJOBPROPERTIES)  (char  *pszDriverName,
+                                         char **pJobProperties);
+typedef int (*PFNFREEOMNIJOBPROPERTIES) (char **pJobProperties);
 
 #define uint32 unsigned long
 #define int32 long
 
 #define strcmpi strcasecmp
 
-
 /* ------ The device descriptors ------ */
 
-typedef struct _DevStruct Omni_Dev,*pDevStruct; /** Type & Pointer of device-specifics */
-typedef const Omni_Dev *opd_pc;       /** Pointer to constant device-specfics */
-
-/* Define data type for this device based on prn_device */
-typedef struct gx_device_omni_s {
-    gx_device_common;
-    gx_prn_device_common;
-    int         buffered_page_exists;
-    long        file_offset_to_data;
-    int         copies_printed;
-    pDevStruct  pDev;            /**    Omni specific extensions */
-} gx_device_omni;
-typedef gx_device_omni omni_device;
-
 typedef struct omni_dev_struct {
-    char cSignature[4];
-    char cVersion[10];
-    void *pDevice;                    // pointer to a standard device
-    void *pPDCDevice;                 // pointer to a PDC device for utilizing IPC
+    char  cSignature[4];
+    int   cbSize;                     // length of the structure
+    char  cVersion[10];
+    char  cOmniVersion[10];
     bool  bPDCDevice;                 // boolean to tell if this is a PDC device or not
-    FILE *pfile;                      // pointer to the output handle from beginjob
+    void *pDevice;                    // pointer to a device
+    FILE *pfpOut;                     // pointer to the output handle from beginjob
+    FILE *pfpErr;
     char *pszJobOptions;              // pointer to the job options
     char  cDebugFile[MAX_LENGTH];     // debug file name
     char  cDeviceName[MAX_LENGTH];
-    char  cOmniVersion[10];
-} core_omni;
-typedef core_omni core_omni_device;
-
-
-
-struct _DevStruct { /* All omni specific data */
-
-   char                  cAsyncOpt[MAX_LENGTH];   /* text value for dither */
+    char  cServer[64];
+    void *pvReserved;
+} core_omni, core_omni_device;
+
+/* All omni specific data */
+typedef struct _DevStruct {
+   char                  cAsyncOpt[MAX_LENGTH];      /* text value for dither */
    char                  cMonoDither[MAX_LENGTH];
-   char                  cServer[32];             //@@05092001
-   char                  cServerFile[256];        //@@05092001
-   void                 *pOutputObject;            // can be used for redirecting cerr in C++ section
+   char                  cServerFile[256];           //@@05092001
    core_omni_device     *pcoreOmni;
    void                 *pCallPtr;
 
@@ -236,64 +212,42 @@
    PFNGETRESOLUTIONINFO  pfnGetResolutionInfo;
    PFNGETMARGININFO      pfnGetMarginInfo;
    PFNBEGINJOB           pfnBeginJob;
-   PFNNEWFRAME           pfnNewFrame;    //@@04162001
+   PFNNEWFRAME           pfnNewFrame;                //@@04162001
    PFNENDJOB             pfnEndJob;
    PFNRASTERIZE          pfnRasterize;
    PFNCREATEDEVICE       pfnCreateDevice;
-   PFNMONODITHER         pfnMonoDither;    //@@04162001
-   PFNGETVERSION         pfnGetVersion;
+   PFNMONODITHER         pfnMonoDither;              //@@04162001
+   PFNGIINIT             pfnGIInit;
+   PFNGITERM             pfnGITerm;
    unsigned long         ulPelSizeCorrection;
 
    int                   iVertDots;
    int                   width;
    int                   height;
    int                   iSync;
-   int                   iPageNumber;  //@@04162001
-   int                   iGSMono;      //@@04252001
-   int                   iUseServer;   //@@05092001
+   int                   iPageNumber;                //@@04162001
+   int                   iGSMono;                    //@@04252001
+   int                   iUseServer;                 //@@05092001
    int                   iUseDialog;
-   FILE                 *ProxyFile;    //@@05092001
+   FILE                 *ProxyFile;                  //@@05092001
 
-   byte                 *outbuf;     /* Output-Buffer */
+   byte                 *outbuf;                     /* Output-Buffer */
 
    int                   iPage;
    int                   iSetup;
-};             /* All upd-specific data */
-
-
-private int
-PrintPage(gx_device_printer *pgx_prt_dev, FILE *prn_stream, int num_copies);
-
-private int
-omni_print_page(gx_device_printer * pdev, FILE * prn_stream);
-
-private int
-SetupDevice(gx_device *pgxdev, gs_param_list *plist);
-
-private int
-OpenDevice(gx_device *pdev  );
-
-private int
-CloseDevice (gx_device * pdev);
-
-private int
-GetDeviceParams(gx_device *pgxdev, gs_param_list *plist);
-
-private int
-BufferPage(gx_device_printer *pgx_prt_dev, FILE *file, int num_copies);
-
-private void
-RenderThread(void *params);
-
-private int
-StartRenderThread(gdev_prn_start_render_params *params);
+} Omni_Dev,
+ *PDEVSTRUCT; /** Type & Pointer of device-specifics */
 
-private int
-OpenRenderDevice(gx_device_printer *ppdev);
-
-private void
-GetSpaceParams(const gx_device_printer *pgx_prt_dev,
- gdev_prn_space_params *space_params);
+/* Define data type for this device based on prn_device */
+typedef struct gx_device_omni_s {
+    gx_device_common;
+    gx_prn_device_common;
+    int         buffered_page_exists;
+    long        file_offset_to_data;
+    int         copies_printed;
+    PDEVSTRUCT  pDev;                 /** Omni specific extensions */
+} gx_device_omni;
+typedef gx_device_omni omni_device;
 
 
 /* Define initializer for device */
@@ -303,57 +257,71 @@
   0, 0L\
 }
 
-/* Print-page, parameters and miscellaneous procedures */
-
-private dev_proc_print_page_copies(PrintPage);
-private prn_dev_proc_buffer_page(BufferPage);
-private prn_dev_proc_start_render_thread(StartRenderThread);
-
-private dev_proc_open_device(OpenDevice);
-
-private dev_proc_print_page(omni_print_page);
-
-private dev_proc_close_device(CloseDevice);
+private int  PrintPage            (gx_device_printer            *pgx_prt_dev,
+                                   FILE                         *prn_stream,
+                                   int                           num_copies);
+private int  omni_print_page      (gx_device_printer            *pdev,
+                                   FILE                         *prn_stream);
+private int  SetupDevice          (gx_device                    *pgxdev,
+                                   gs_param_list                *plist);
+private int  OpenDevice           (gx_device                    *pdev);
+private int  CloseDevice          (gx_device                    *pdev);
+private int  GetDeviceParams      (gx_device                    *pgxdev,
+                                   gs_param_list                *plist);
+private int  BufferPage           (gx_device_printer            *pgx_prt_dev,
+                                   FILE                         *file,
+                                   int                           num_copies);
+private void RenderThread         (void                         *params);
+private int  StartRenderThread    (gdev_prn_start_render_params *params);
+private int  OpenRenderDevice     (gx_device_printer            *ppdev);
+private void GetSpaceParams       (const gx_device_printer      *pgx_prt_dev,
+                                   gdev_prn_space_params        *space_params);
 
-private dev_proc_get_params(GetDeviceParams);
-
-private dev_proc_put_params(SetupDevice);
-
-private dev_proc_output_page(PrintPageMultiple);
-
-private prn_dev_proc_get_space_params(GetSpaceParams);
+/* Print-page, parameters and miscellaneous procedures */
+private      dev_proc_print_page_copies       (PrintPage);
+private      prn_dev_proc_buffer_page         (BufferPage);
+private      prn_dev_proc_start_render_thread (StartRenderThread);
+private      dev_proc_open_device             (OpenDevice);
+private      dev_proc_print_page              (omni_print_page);
+private      dev_proc_close_device            (CloseDevice);
+private      dev_proc_get_params              (GetDeviceParams);
+private      dev_proc_put_params              (SetupDevice);
+private      dev_proc_output_page             (PrintPageMultiple);
+private      prn_dev_proc_get_space_params    (GetSpaceParams);
 
 /* 24-bit color. only want 16M colors  */
 
 private gx_device_procs omni16m_procs = {
-                  OpenDevice,                //  open_device
-                  NULL,                      //  get_initial_matrix
-                  NULL,                      //  sync_output
-                  //gx_default_sync_output,    // sync_output
-                  gdev_prn_output_page,      //  output_page
-                  CloseDevice,               //  close_device
-                  NULL,// bmp_map_16m_rgb_color,     //  map_rgb_color      @@04252001
-                  NULL, // bmp_map_16m_color_rgb,     //  map_color_rgb     @@04252001
-                  NULL,                          /** fill_rectangle */
-                  NULL,                          /** tile_rectangle */
-                  NULL,                          /** copy_mono */
-                  NULL,                          /** copy_color */
-                  NULL,                          /** draw_line */
-                  //NULL,                      // Reads scan lines
-                  gx_default_get_bits,                      // Reads scan lines
-                  GetDeviceParams,            /** Export parameters, special */
-                  SetupDevice};           /** Import parameters, special */
+                  OpenDevice,                     //  open_device
+                  NULL,                           //  get_initial_matrix
+                  NULL,                           //  sync_output
+//////////////////gx_default_sync_output,         // sync_output
+                  gdev_prn_output_page,           //  output_page
+                  CloseDevice,                    //  close_device
+                  NULL, // bmp_map_16m_rgb_color, //  map_rgb_color      @@04252001
+                  NULL, // bmp_map_16m_color_rgb, //  map_color_rgb     @@04252001
+                  NULL,                           /** fill_rectangle */
+                  NULL,                           /** tile_rectangle */
+                  NULL,                           /** copy_mono */
+                  NULL,                           /** copy_color */
+                  NULL,                           /** draw_line */
+//////////////////NULL,                           // Reads scan lines
+                  gx_default_get_bits,            // Reads scan lines
+                  GetDeviceParams,                /** Export parameters, special */
+                  SetupDevice                     /** Import parameters, special */
+};
 
 
 gx_device_omni far_data gs_omni_device =
-  omni_device(omni16m_procs,"omni",
-               DEFAULT_WIDTH_10THS, /* 85 x 110 - page physical area non clipped */
+  omni_device (omni16m_procs,
+               "omni",
+               DEFAULT_WIDTH_10THS,  /* 85 x 110 - page physical area non clipped */
                DEFAULT_HEIGHT_10THS,
-               X_DPI, Y_DPI,        /* std resolution - 72 dpi          */
-               0,0,0,0,             /* margins - need defaults  */
-             //  24,                                                          @@04252001
-               1,                  /* Bpp value */
-               omni_print_page);   // sync routine for output of raster data
+               X_DPI, Y_DPI,         /* std resolution - 72 dpi          */
+               0,0,0,0,              /* margins - need defaults  */
+///////////////24,                   // @@04252001
+               1,                    /* Bpp value */
+               omni_print_page);     // sync routine for output of raster data
 
 
 /* ------------------------------------------------------*/
@@ -361,140 +329,151 @@
 
 /* Generic routine to send the page to the printer. */
 private int
-PrintPageMultiple(gx_device *pDev, int iCopies, int flush)
+PrintPageMultiple (gx_device *pDev, int iCopies, int flush)
 {
-    /*
-     * HACK: open the printer page with the positionable attribute since
-     * we need to seek back & forth to support partial rendering.
-     */
-
-    if ( iCopies > 0 || !flush ) {
-    int iRet = gdev_prn_open_printer_positionable(pDev, 1, 1);
-
-    if ( iRet < 0 )
-       return iRet;
-    }
-    return gdev_prn_output_page(pDev, iCopies, flush);
+   /*
+    * HACK: open the printer page with the positionable attribute since
+    * we need to seek back & forth to support partial rendering.
+    */
+   if (  iCopies > 0
+      || !flush
+      )
+   {
+      int iRet = gdev_prn_open_printer_positionable (pDev, 1, 1);
+
+      if (iRet < 0)
+         return iRet;
+   }
+
+   return gdev_prn_output_page(pDev, iCopies, flush);
 }
 
 /* ------------ Writer Instance procedures ---------- */
 
 /* Writer's open procedure */
 private int
-OpenDevice(gx_device *pdev  /* Driver instance to open */)
+OpenDevice (gx_device *pdev  /* Driver instance to open */)
 {
-    gx_device_omni * const pwdev = (gx_device_omni *)pdev;
-    pDevStruct              pDev  = pwdev->pDev;
-    int max_width;
-    int max_raster;
-    int min_band_height;
-    int max_src_image_row;
-
-    if (!pDev || !pDev->hmodOmni)
-    {
-       /* SetupDevice is called before OpenDevice is called.  Therefore, the
-       ** initial loading of the omni driver is done there.  If that has failed
-       ** (the library handle is 0), then fail this call.
-       */
+   gx_device_omni * const pwdev              = (gx_device_omni *)pdev;
+   PDEVSTRUCT             pDev               = pwdev->pDev;
+   int                    max_width;
+   int                    max_raster;
+   int                    min_band_height;
+   int                    max_src_image_row;
+
+   if (  !pDev
+      || !pDev->hmodOmni
+      )
+   {
+      /* SetupDevice is called before OpenDevice is called.  Therefore, the
+      ** initial loading of the omni driver is done there.  If that has failed
+      ** (the library handle is 0), then fail this call.
+      */
+      return e_Fatal;
+   }
+
+   pDev->iUseServer  = 0;  //@@05092001
+   pDev->iPageNumber = 0;  //@@04162001
+   pDev->iUseDialog  = 0;
+
+   /*
+    * Set up device's printer proc vector to point to this driver, since
+    * there are no convenient macros for setting them up in static template.
+    */
+   if (pDev->iSync)
+   {
+      init_async_render_procs (pwdev,
+                               StartRenderThread,
+                               BufferPage,
+                               PrintPage);
+   }
+   else
+   {
+      // don't really think this needs to be done but we'll do it anyway
+      set_dev_proc (pdev, sync_output, gx_default_sync_output);
+   }
 
-       return e_Fatal;
-    }
+   set_dev_proc (pdev, put_params, SetupDevice);
+   set_dev_proc (pdev, get_params, GetDeviceParams);
 
-    pDev->iUseServer = 0;                                            //@@05092001
-    pDev->iPageNumber = 0;  //@@04162001
-    pDev->iUseDialog = 0;
-
-//    if(pDev->pszOtherOptions)
-//       *pDev->pszOtherOptions = '\0';
-
-    /*
-     * Set up device's printer proc vector to point to this driver, since
-     * there are no convenient macros for setting them up in static template.
-     */
-    if(pDev->iSync)
-    {
-        init_async_render_procs(pwdev, StartRenderThread,
-                    BufferPage,
-                    PrintPage);
-    }
-    else
-    {
-// don't really think this needs to be done but we'll do it anyway
-        set_dev_proc(pdev, sync_output, gx_default_sync_output);
-    }
-
-    set_dev_proc(pdev, put_params, SetupDevice);
-    set_dev_proc(pdev, get_params, GetDeviceParams);
-
-    if(!pDev->iGSMono)                                                  //@@04252001
-    {                                                                   //@@04252001
-        if (fDebugOutput) fprintf(stderr, "Remapping color pointers\n");
-        set_dev_proc(pdev, map_rgb_color, bmp_map_16m_rgb_color);       //@@04252001
-        set_dev_proc(pdev, map_color_rgb, bmp_map_16m_color_rgb);       //@@04252001
-    }                                                                   //@@04252001
-
-    if(pDev->iSync)
-    {
-        set_dev_proc(pdev, output_page, PrintPageMultiple);
-        pwdev->printer_procs.get_space_params = GetSpaceParams;
-        pwdev->printer_procs.open_render_device =
-        OpenRenderDevice;	/* Included for tutorial value */
-    }
-    /*
-     * Determine MAXIMUM parameters this device will have to support over
-     * lifetime.  See comments for GetSpaceParams().
-     */
-    max_width = DEFAULT_WIDTH_10THS * 60 * 16;   /* figure max wid = default @ 600dpi */
-                                       /* multiplied by 2 for 1200 dpi */
-    min_band_height = max(1, (DEFAULT_HEIGHT_10THS * 60) / 100);
-    max_raster = (max_width * pwdev->color_info.depth) / 8;	/* doesn't need to be super accurate */
-    max_src_image_row = max_width * 3 * 2;
+   if (!pDev->iGSMono)                                                 //@@04252001
+   {                                                                   //@@04252001
+      if (fDebugOutput) fprintf(stderr, "Remapping color pointers\n");
 
-#ifdef OMNI_ASYNC
-    if(pDev->iSync)
-    {
-        return gdev_prn_async_write_open((gx_device_printer *)pdev,
-                         max_raster, min_band_height,
-                         max_src_image_row);
+      set_dev_proc(pdev, map_rgb_color, bmp_map_16m_rgb_color);        //@@04252001
+      set_dev_proc(pdev, map_color_rgb, bmp_map_16m_color_rgb);        //@@04252001
+   }                                                                   //@@04252001
 
-    }
-    else
-#endif
-    {
-       return gdev_prn_open(pdev);
-    }
+   if (pDev->iSync)
+   {
+      set_dev_proc(pdev, output_page, PrintPageMultiple);
+      pwdev->printer_procs.get_space_params = GetSpaceParams;
+      pwdev->printer_procs.open_render_device =
+      OpenRenderDevice;        /* Included for tutorial value */
+   }
 
+   /*
+    * Determine MAXIMUM parameters this device will have to support over
+    * lifetime.  See comments for GetSpaceParams().
+    */
+   max_width = DEFAULT_WIDTH_10THS * 60 * 16;   /* figure max wid = default @ 600dpi */
+                                      /* multiplied by 2 for 1200 dpi */
+   min_band_height = max(1, (DEFAULT_HEIGHT_10THS * 60) / 100);
+   max_raster = (max_width * pwdev->color_info.depth) / 8;        /* doesn't need to be super accurate */
+   max_src_image_row = max_width * 3 * 2;
+
+#ifdef OMNI_ASYNC
+   if (pDev->iSync)
+   {
+      return gdev_prn_async_write_open ((gx_device_printer *)pdev,
+                                        max_raster,
+                                        min_band_height,
+                                        max_src_image_row);
 
+   }
+   else
+#endif
+   {
+      return gdev_prn_open(pdev);
+   }
 }
 
 private int
 CloseDevice (gx_device * pdev)
 {
    gx_device_omni * const pwdev = (gx_device_omni *)pdev;
-   pDevStruct              pDev  = pwdev->pDev;
+   PDEVSTRUCT             pDev  = pwdev->pDev;
 
-   if(!pDev || !pDev->pcoreOmni->pDevice)
+   if (  !pDev
+      || !pDev->pcoreOmni->pDevice
+      )
    {
      return_error(gs_error_Fatal);  // handle no pDev
    }
+
    /***
     *     WE NEED TO TERMINATE HERE!!!!!!!!!
     *     @@04162001
     ***/
    if (pDev->pfnEndJob)
    {
-       pDev->pfnEndJob ((void*) pDev->pCallPtr, pDev->pOutputObject);
+       pDev->pfnEndJob ((void*)pDev->pCallPtr);
        pDev->pfnEndJob = 0;
    }
 
    if (pDev->pcoreOmni->pszJobOptions)
    {
-       gs_free(pDev->pcoreOmni->pszJobOptions,strlen(pDev->pcoreOmni->pszJobOptions)+1, 1, "Option String");
+      gs_free (pDev->pcoreOmni->pszJobOptions,strlen(pDev->pcoreOmni->pszJobOptions)+1, 1, "Option String");
+   }
+
+   if (pDev->pfnGITerm)
+   {
+      pDev->pfnGITerm (pDev->pcoreOmni);
    }
 
-   if (pDev->pcoreOmni)    
+   if (pDev->pcoreOmni)
    {
-      gs_free(pDev->pcoreOmni , sizeof(core_omni_device), 1, "omni/device" );
+      gs_free (pDev->pcoreOmni, sizeof (core_omni_device), 1, "omni/device");
       pDev->pcoreOmni = 0;
    }
 
@@ -510,21 +489,9 @@
       pDev->hmodOmni = 0;
    }
 
-
-   // Removed following code so commandline server invocation is
-   // just -sserver  @@01302002
-
-//   if(pDev->ProxyFile)                                    //@@05092001
-//   {                                                      //@@05092001
-//       fclose(pDev->ProxyFile);                           //@@05092001
-//   }                                                      //@@05092001
-
    return gdev_prn_close (pdev);
-
 }
 
-
-
 /* -------------------------------------------------------------------------*/
 /*                                                                          */
 /*  Function: GetDeviceParams                                               */
@@ -538,24 +505,23 @@
 private int
 GetDeviceParams(gx_device *pgxdev, gs_param_list *plist)
 {
-   omni_device *const      odev       = (omni_device *) pgxdev;
-   pDevStruct              pDev       = odev->pDev;
-
-   int iReturnCode = 0;
-   gs_param_string    strdata;
-
-   const char   *pszDeviceName       = "";
-   const char   *pszDebug            = "";
-   const char   *pszOther            = "";
-   const char   *pszAsync            = "";
-   const char   *pszMonoDither       = "";
-   const char   *pszServer           = "";
-   char    pszTemp[3];
-   unsigned long ulPelSizeCorrection = 100;
-   bool          bPersist            = false;
+   omni_device *const      odev                = (omni_device *) pgxdev;
+   PDEVSTRUCT              pDev                = odev->pDev;
+   int                     iReturnCode         = 0;
+   gs_param_string         strdata;
+
+   const char             *pszDeviceName       = "";
+   const char             *pszDebug            = "";
+   const char             *pszOther            = "";
+   const char             *pszAsync            = "";
+   const char             *pszMonoDither       = "";
+   const char             *pszServer           = "";
+   char                    pszTemp[3];
+   unsigned long           ulPelSizeCorrection = 100;
+   bool                    bPersist            = false;
 
+   iReturnCode = gdev_prn_get_params (pgxdev, plist);
 
-   iReturnCode = gdev_prn_get_params ( pgxdev, plist );
    if (pDev)
    {
        bPersist            = true;
@@ -565,17 +531,15 @@
        pszAsync            = pDev->cAsyncOpt;
        ulPelSizeCorrection = pDev->ulPelSizeCorrection;
        pszMonoDither       = pDev->cMonoDither;
-
-       // Removed following code so commandline server invocation is
-       // just -sserver  @@01302002
-//       pszServer           = pDev->cServerFile;              //@@05092001
+       pszServer           = pDev->pcoreOmni->cServer;
 
        // Return if we already did our work here
-       if(strlen(pszDeviceName) > 0)
+       if (strlen (pszDeviceName) > 0)
        {
-           return iReturnCode;
+          return iReturnCode;
        }
    }
+
    strdata.data = pszDeviceName;
    strdata.size = strlen(pszDeviceName);
    strdata.persistent = bPersist;
@@ -586,16 +550,18 @@
    strdata.persistent = bPersist;
    iReturnCode = param_write_string(plist,"dbgout",&strdata);
 
-   if(pDev && pDev->pcoreOmni->pszJobOptions)
+   if (  pDev
+      && pDev->pcoreOmni->pszJobOptions
+      )
    {
-       strdata.size = strlen(pszOther);
-       strdata.data = pszOther;
+      strdata.size = strlen(pszOther);
+      strdata.data = pszOther;
    }
    else
    {
-       pszTemp[0] = '\0';
-       strdata.size = 0;
-       strdata.data = pszTemp;
+      pszTemp[0] = '\0';
+      strdata.size = 0;
+      strdata.data = pszTemp;
    }
 
    strdata.persistent = bPersist;
@@ -619,7 +585,7 @@
    strdata.data = pszServer;                                      //@@05092001
    strdata.size = strlen(pszServer);                              //@@05092001
    strdata.persistent = bPersist;                                 //@@05092001
-   iReturnCode = param_write_string(plist,"jobdialog",&strdata);     //@@05092001
+   iReturnCode = param_write_string(plist,"jobdialog",&strdata);  //@@05092001
 
    iReturnCode = param_write_long(plist,"PelSizeCorrection",&ulPelSizeCorrection);
 
@@ -640,73 +606,79 @@
 private int
 SetupDevice(gx_device *pgxdev, gs_param_list *plist)
 {
-
-   int                     iReturnCode, i;
+   int                     iReturnCode,
+                           i;
    BOOL                    bRet;
    HWMARGINS               hwMargins;
    HWRESOLUTION            hwRes;
-   gx_device_omni * const prgxdev  = (gx_device_omni *)pgxdev;
-   pDevStruct              pDev     = prgxdev->pDev;
-   char *pszDeviceLib = 0;
-   static char cOmnilib[] = "libomni.so";
-   static char cDialogName[] = "libomnijobdialog.so";
-
-   static char *apszLibraryPaths[] = {
+   gx_device_omni * const  prgxdev            = (gx_device_omni *)pgxdev;
+   PDEVSTRUCT              pDev               = prgxdev->pDev;
+   char                   *pszDeviceLib       = 0;
+   static char             cOmnilib[]         = "libomni.so";
+   static char             cDialogName[]      = "libomnijobdialog.so";
+   static const char      *apszLibraryPaths[] = {
       "/usr/lib/Omni/",
       "/opt/Omni/bin/",
+      "/opt/Omni/lib/",
       "./",
       ""                // give a chance for $LD_LIBRARY_PATH to work
    };
-
-   PRINTMODE prtMode;  //definition of printed output Bpp ..
-
-// gs_param_string         =    data, size, persistant + byte data
-   gs_param_string         fname    = { NULL, 0, false };
-   gs_param_string         deffname = { NULL, 0, false };
+   PRINTMODE               prtMode;           // definition of printed output Bpp ..
+   gs_param_string         fname;
+   gs_param_string         deffname;
+
+   fname.data          = NULL;
+   fname.size          = 0;
+   fname.persistent    = false;
+   deffname.data       = NULL;
+   deffname.size       = 0;
+   deffname.persistent = false;
 
    if (pDev == NULL)
    {
-       pDevStruct p;
+      PDEVSTRUCT p;
 
-       p = (pDevStruct)gs_malloc ( 1, sizeof (Omni_Dev), "omni/instance" );
-       if(!p)
-       {
-           fprintf(stderr, "<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n");
-           fprintf(stderr, "   Failed allocation of p in SetupDevice\n");
-           return_error(gs_error_VMerror);
-       }
-       prgxdev->pDev = p;
+      p = (PDEVSTRUCT)gs_malloc (1, sizeof (Omni_Dev), "omni/instance");
+      if (!p)
+      {
+          fprintf(stderr, "<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n");
+          fprintf(stderr, "   Failed allocation of p in SetupDevice\n");
+          return_error(gs_error_VMerror);
+      }
+      prgxdev->pDev = p;
 
+      if (!(pDev = prgxdev->pDev))
+      {
+         return_error(gs_error_Fatal);
+      }
+      else
+      {
+         memset (pDev, 0, sizeof (Omni_Dev));
 
-       if (!(pDev = prgxdev->pDev))
-       {
-          return_error(gs_error_Fatal);
-       }
-       else
-       {
-          memset (pDev, 0, sizeof (Omni_Dev));
-          pDev->pcoreOmni = (core_omni_device *)gs_malloc ( 1, sizeof (core_omni_device), "omni/device" );
+         pDev->pcoreOmni = (core_omni_device *)gs_malloc (1, sizeof (core_omni_device), "omni/device");
 
-          if(!pDev->pcoreOmni)
-              return_error(gs_error_Fatal);
+         if (!pDev->pcoreOmni)
+            return_error(gs_error_Fatal);
 
-          memset(pDev->pcoreOmni, 0, sizeof(core_omni_device));
-          pDev->pcoreOmni->bPDCDevice = false;
-          memcpy(pDev->pcoreOmni->cSignature, (char *)Signature, 4);
+         memset (pDev->pcoreOmni, 0, sizeof (core_omni_device));
 
-         // prgxdev->pDev->pszOtherOptions = '\0';
-       }
+         memcpy ((void *)pDev->pcoreOmni->cSignature, (const void *)Signature, 4);
+
+         pDev->pcoreOmni->cbSize = sizeof (core_omni_device);
+      }
    }
 
    if (!pDev->hmodOmni)
    {
       pDev->ulPelSizeCorrection = 100;
 
-      for (i = 0; i < 4 && !pDev->hmodOmni; i++)
+      for (i = 0; i < sizeof (apszLibraryPaths)/sizeof (apszLibraryPaths[0]) && !pDev->hmodOmni; i++)
       {
-          pszDeviceLib = (char *)gs_malloc (1, strlen (cOmnilib)
-                                           + strlen (apszLibraryPaths[i])
-                                           + 1, "Devicestring");
+          pszDeviceLib = (char *)gs_malloc (1,
+                                            strlen (cOmnilib)
+                                            + strlen (apszLibraryPaths[i])
+                                            + 1,
+                                            "Devicestring");
           if (pszDeviceLib)
           {
               sprintf (pszDeviceLib, "%s%s", apszLibraryPaths[i], cOmnilib);
@@ -715,39 +687,38 @@
           gs_free (pszDeviceLib,strlen(pszDeviceLib)+1, 1, "Devicestring");
       }
 
-
       if (!pDev->hmodOmni)
       {
-              // Failure!
-              fprintf (stderr, "\n<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n\n");
-              fprintf (stderr, "Error: Could not load libomni.so!\n\n");
-
-              // @TBD - why doesnt return_error(gs_error_Fatal) work?
-              //        If it is in, then we get the following:
-              //
-              // Unrecoverable error: rangecheck in .putdeviceprops
-              //
-              // Unexpected interpreter error -15.
-              // Error object: (1488)op_array(586)0x81bc858:.putdeviceprops
-              // Execution stack at 0x81b0940:
-              // 0x81c6c74: 0x0f oper --F---e-- 0x0000 0x08084fcc = %interp_exit
-              // 0x81c6c7c: 0x03 file --G-rxe-- 0x0001 0x081bd010
-              // 0x81c6c84: 0x0e null --F---e-- 0x0000 0x08086b94
-              // 0x81c6c8c: 0x0b int  --F------ 0x01ac 0x00000008 = 8
-              // 0x81c6c94: 0x0b int  --F------ 0x0007 0x00000004 = 4
-              // 0x81c6c9c: 0x0f oper --F---e-- 0x0000 0x08086b80 = %oparray_pop
-              // 0x81c6ca4: 0x05 mpry --G-rxe-- 0x0002 0x0821032c
-              // 0x81c6cac: 0x0e null --F---e-- 0x0000 0x08086b94
-              // 0x81c6cb4: 0x0b int  --F------ 0x0001 0x00000008 = 8
-              // 0x81c6cbc: 0x0b int  --F------ 0x0000 0x00000004 = 4
-              // 0x81c6cc4: 0x0f oper --F---e-- 0x0000 0x08086b80 = %oparray_pop
-              // 0x81c6ccc: 0x05 mpry --G-rxe-- 0x0039 0x08210dae
-              // Dictionary stack at 0x81b0a00:
-              // 0x81c74a4: 0x02 dict --Gwrx--- 0x081b 0x081b947c
-              // 0x81c74ac: 0x02 dict --Gwrx--- 0x081c 0x0821d0a8
-              // 0x81c74b4: 0x02 dict --Lwrx--- 0x4000 0x081c1388
-              // 0x81c74bc: 0x02 dict --Gwrx--- 0x081b 0x081b947c
-              return 1;
+         // Failure!
+         fprintf (stderr, "\n<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n\n");
+         fprintf (stderr, "Error: Could not load libomni.so!\n\n");
+
+         // @TBD - why doesnt return_error(gs_error_Fatal) work?
+         //        If it is in, then we get the following:
+         //
+         // Unrecoverable error: rangecheck in .putdeviceprops
+         //
+         // Unexpected interpreter error -15.
+         // Error object: (1488)op_array(586)0x81bc858:.putdeviceprops
+         // Execution stack at 0x81b0940:
+         // 0x81c6c74: 0x0f oper --F---e-- 0x0000 0x08084fcc = %interp_exit
+         // 0x81c6c7c: 0x03 file --G-rxe-- 0x0001 0x081bd010
+         // 0x81c6c84: 0x0e null --F---e-- 0x0000 0x08086b94
+         // 0x81c6c8c: 0x0b int  --F------ 0x01ac 0x00000008 = 8
+         // 0x81c6c94: 0x0b int  --F------ 0x0007 0x00000004 = 4
+         // 0x81c6c9c: 0x0f oper --F---e-- 0x0000 0x08086b80 = %oparray_pop
+         // 0x81c6ca4: 0x05 mpry --G-rxe-- 0x0002 0x0821032c
+         // 0x81c6cac: 0x0e null --F---e-- 0x0000 0x08086b94
+         // 0x81c6cb4: 0x0b int  --F------ 0x0001 0x00000008 = 8
+         // 0x81c6cbc: 0x0b int  --F------ 0x0000 0x00000004 = 4
+         // 0x81c6cc4: 0x0f oper --F---e-- 0x0000 0x08086b80 = %oparray_pop
+         // 0x81c6ccc: 0x05 mpry --G-rxe-- 0x0039 0x08210dae
+         // Dictionary stack at 0x81b0a00:
+         // 0x81c74a4: 0x02 dict --Gwrx--- 0x081b 0x081b947c
+         // 0x81c74ac: 0x02 dict --Gwrx--- 0x081c 0x0821d0a8
+         // 0x81c74b4: 0x02 dict --Lwrx--- 0x4000 0x081c1388
+         // 0x81c74bc: 0x02 dict --Gwrx--- 0x081b 0x081b947c
+         return 1;
       }
 
       g_module_symbol (pDev->hmodOmni, "GetPrintModeInfo", (gpointer *)&pDev->pfnGetPrintModeInfo);
@@ -778,20 +749,21 @@
 
       if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (Rasterize) = 0x%08x\n", (int)pDev->pfnRasterize);
 
-      g_module_symbol (pDev->hmodOmni, "createDevice", (gpointer *)&pDev->pfnCreateDevice);
+      g_module_symbol (pDev->hmodOmni, "CreateDevice", (gpointer *)&pDev->pfnCreateDevice);
 
-      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (createDevice) = 0x%08x\n", (int)pDev->pfnCreateDevice);
+      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (CreateDevice) = 0x%08x\n", (int)pDev->pfnCreateDevice);
 
-//      g_module_symbol (pDev->hmodOmni, "DiffusionDither__FP20_DIFFUSIONDITHERINFOP11_IMAGEINFOSPPUcUi", (gpointer *)&pDev->pfnMonoDither);
       g_module_symbol (pDev->hmodOmni, "DiffusionDither", (gpointer *)&pDev->pfnMonoDither);
 
-//      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (DiffusionDither__FP20_DIFFUSIONDITHERINFOP11_IMAGEINFOSPPUcUi) = 0x%08x\n", (int)pDev->pfnMonoDither);
       if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (DiffusionDither) = 0x%08x\n", (int)pDev->pfnMonoDither);
 
-//      g_module_symbol (pDev->hmodOmni, "getInterfaceVersion__FPvPc", (gpointer *)&pDev->pfnGetVersion);
-      g_module_symbol (pDev->hmodOmni, "getInterfaceVersion", (gpointer *)&pDev->pfnGetVersion);
-          
+      g_module_symbol (pDev->hmodOmni, "GhostscriptInferfaceInit", (gpointer *)&pDev->pfnGIInit);
+
+      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (GhostscriptInferfaceInit) = 0x%08x\n", (int)pDev->pfnGIInit);
+
+      g_module_symbol (pDev->hmodOmni, "GhostscriptInferfaceTerm", (gpointer *)&pDev->pfnGITerm);
 
+      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (GhostscriptInferfaceTerm) = 0x%08x\n", (int)pDev->pfnGITerm);
 
       if (  !pDev->pfnCreateDevice
          || !pDev->pfnBeginJob
@@ -814,91 +786,98 @@
          // @TBD - why doesnt return_error(gs_error_Fatal) work? (see above)
          return 1;
       }
-
    }
 
-//   device name in structure - need to fail if none
+   // device name in structure - need to fail if none
    fname = deffname;
-   iReturnCode = param_read_string(plist,"DeviceName",&fname);
-   if(0 > iReturnCode)
+   iReturnCode = param_read_string (plist, "DeviceName", &fname);
+   if (0 > iReturnCode)
    {
       pDev->pcoreOmni->cDeviceName[0] = '\0';
-      if(iReturnCode < 0)
+
+      if (iReturnCode < 0)
       {
-          iReturnCode = param_read_null(plist,"DeviceName");
-          if(iReturnCode != 0)
+         iReturnCode = param_read_null(plist,"DeviceName");
+         if (iReturnCode != 0)
             fprintf(stderr, "Error Reading DeviceName parameter\n");
       }
    }
    else
    {
-      if((iReturnCode < 1) && (fname.size > 0))
+      if (  (iReturnCode < 1)
+         && (fname.size > 0)
+         )
       {
-          memcpy (pDev->pcoreOmni->cDeviceName, fname.data, fname.size );
-          pDev->pcoreOmni->cDeviceName[fname.size] = '\0';
+         memcpy (pDev->pcoreOmni->cDeviceName, fname.data, fname.size);
+         pDev->pcoreOmni->cDeviceName[fname.size] = '\0';
       }
-
    }
 
    // set debugging file name
    fname = deffname;
    iReturnCode = 0;
-   iReturnCode = param_read_string(plist,"dbgout",&fname);
-   if(0 > iReturnCode)
+   iReturnCode = param_read_string (plist, "dbgout", &fname);
+   if (0 > iReturnCode)
    {
       pDev->pcoreOmni->cDebugFile[0] = '\0';
-      if(iReturnCode < 0)
+      if (iReturnCode < 0)
       {
-          iReturnCode = param_read_null(plist,"dbgout");
-          if(iReturnCode != 0)
-            fprintf(stderr, "Error Reading dbgout parameter\n");
+         iReturnCode = param_read_null (plist, "dbgout");
+         if (iReturnCode != 0)
+            fprintf (stderr, "Error Reading dbgout parameter\n");
       }
    }
    else
    {
-      if((iReturnCode < 1) && (fname.size > 0))
+      if (  (iReturnCode < 1)
+         && (fname.size > 0)
+         )
       {
-          memcpy ( pDev->pcoreOmni->cDebugFile, fname.data, fname.size );
-          pDev->pcoreOmni->cDebugFile[fname.size] = '\0';
+         memcpy (pDev->pcoreOmni->cDebugFile, fname.data, fname.size);
+         pDev->pcoreOmni->cDebugFile[fname.size] = '\0';
       }
    }
 
    // set Async option
    fname = deffname;
    iReturnCode = 0;
-   iReturnCode = param_read_string(plist,"async",&fname);
+   iReturnCode = param_read_string(plist, "async", &fname);
    if(0 > iReturnCode)
    {
       pDev->cAsyncOpt[0] = '\0';
       pDev->iSync = 0;
-      iReturnCode = param_read_null(plist,"async");
-      if(iReturnCode != 0)
+      iReturnCode = param_read_null (plist, "async");
+      if (iReturnCode != 0)
         fprintf(stderr, "Error Reading async parameter\n");
    }
    else
    {
-      if((iReturnCode < 1) && (fname.size > 0))
+      if (  (iReturnCode < 1)
+         && (fname.size > 0)
+         )
       {
-          memcpy ( pDev->cAsyncOpt, fname.data, fname.size );
-          pDev->cAsyncOpt[fname.size] = '\0';
-          if(!strcmp(pDev->cAsyncOpt, "TRUE") || !strcmp(pDev->cAsyncOpt, "true"))
-          {
-              pDev->iSync = 1;
-          }
-          else
-          {
-              pDev->iSync = 0;
-          }
+         memcpy (pDev->cAsyncOpt, fname.data, fname.size);
+         pDev->cAsyncOpt[fname.size] = '\0';
+         if (  !strcmp (pDev->cAsyncOpt, "TRUE")
+            || !strcmp(pDev->cAsyncOpt, "true")
+            )
+         {
+            pDev->iSync = 1;
+         }
+         else
+         {
+            pDev->iSync = 0;
+         }
       }
    }
 
    iReturnCode = param_read_long(plist,"PelSizeCorrection",&pDev->ulPelSizeCorrection);
-   if(0 > iReturnCode)
+   if (0 > iReturnCode)
    {
-      if(iReturnCode < 0)
+      if (iReturnCode < 0)
       {
-          iReturnCode = param_read_null(plist,"PelSizeCorrection");
-          if(iReturnCode != 0)
+         iReturnCode = param_read_null(plist,"PelSizeCorrection");
+         if (iReturnCode != 0)
             fprintf(stderr, "Error Reading PelSizeCorrection parameter\n");
       }
    }
@@ -906,273 +885,278 @@
    /*
     *  Set user options for the job
     */
-
    fname = deffname;
    iReturnCode = param_read_string(plist,"properties",&fname);
-   if(0 > iReturnCode)
+   if (0 > iReturnCode)
    {
-      if(iReturnCode < 0)
+      if (iReturnCode < 0)
       {
-          iReturnCode = param_read_null(plist,"properties");
-          if(iReturnCode != 0)
+         iReturnCode = param_read_null(plist,"properties");
+         if (iReturnCode != 0)
             fprintf(stderr, "Error Reading properties parameter\n");
       }
    }
    else
    {
-       if((iReturnCode < 1) && (fname.size > 0))
-       {
-           if(!pDev->pcoreOmni->pszJobOptions)
-             pDev->pcoreOmni->pszJobOptions = (char *) gs_malloc(1,fname.size+1, "Option String");
-           memcpy ( pDev->pcoreOmni->pszJobOptions, fname.data, fname.size );
-           pDev->pcoreOmni->pszJobOptions[fname.size] = '\0';
-       }
+      if (  (iReturnCode < 1)
+         && (fname.size > 0)
+         )
+      {
+         if (!pDev->pcoreOmni->pszJobOptions)
+            pDev->pcoreOmni->pszJobOptions = (char *)gs_malloc(1,fname.size+1, "Option String");
+         memcpy (pDev->pcoreOmni->pszJobOptions, fname.data, fname.size);
+         pDev->pcoreOmni->pszJobOptions[fname.size] = '\0';
+      }
    }
 
    /*
     *  Set user options for monodither by GS
     */
-
    fname = deffname;
    iReturnCode = param_read_string(plist,"monodither",&fname);
-   if(0 > iReturnCode)
+   if (0 > iReturnCode)
    {
-      if(iReturnCode < 0)
+      if (iReturnCode < 0)
       {
-          iReturnCode = param_read_null(plist,"monodither");
-          if(iReturnCode != 0)
+         iReturnCode = param_read_null(plist,"monodither");
+         if (iReturnCode != 0)
             fprintf(stderr, "Error Reading monodither parameter\n");
       }
    }
    else
    {
-       if((iReturnCode < 1) && (fname.size > 0))
-       {
-           memcpy ( pDev->cMonoDither, fname.data, fname.size );
-           pDev->cMonoDither[fname.size] = '\0';
+      if (  (iReturnCode < 1)
+         && (fname.size > 0)
+         )
+      {
+         memcpy (pDev->cMonoDither, fname.data, fname.size);
+         pDev->cMonoDither[fname.size] = '\0';
 
-           if(!strcmp(pDev->cMonoDither, "GSMONO"))
-           {
+         if (!strcmp(pDev->cMonoDither, "GSMONO"))
+         {
+            if (fDebugOutput) fprintf(stderr,"turning on GSMONO dither\n");
 
-               if (fDebugOutput) fprintf(stderr,"turning on GSMONO dither\n");
-               pDev->iGSMono = 1;
-           }
-           else
-           {
-               pDev->iGSMono = 0;
-           }
-       }
+            pDev->iGSMono = 1;
+         }
+         else
+         {
+            pDev->iGSMono = 0;
+         }
+      }
    }
 
    /*
     *  Set user options for client / server function
     */
-
    fname = deffname;                                                //@@05092001
    iReturnCode = param_read_string(plist,"server",&fname);          //@@05092001
 
-   if(0 > iReturnCode)                                              //@@05092001
+   if (0 > iReturnCode)                                             //@@05092001
    {                                                                //@@05092001
-      if(iReturnCode < 0)                                           //@@05092001
+      if (iReturnCode < 0)                                          //@@05092001
       {                                                             //@@05092001
-          iReturnCode = param_read_null(plist,"server");            //@@05092001
-          if(iReturnCode != 0)                                      //@@05092001
+         iReturnCode = param_read_null(plist,"server");             //@@05092001
+         if (iReturnCode != 0)                                      //@@05092001
             fprintf(stderr, "Error Reading server parameter\n");    //@@05092001
       }                                                             //@@05092001
    }                                                                //@@05092001
    else                                                             //@@05092001
    {                                                                //@@05092001
-       if( !iReturnCode) 
-       {
-           if (fDebugOutput) fprintf(stderr, "Utilizing Server\n");   
-           pDev->iUseServer = 1;                                            
-       }
-
+      if (  (iReturnCode < 1)
+         && (fname.size > 0)
+         )
+      {
+         memcpy (pDev->pcoreOmni->cServer, fname.data, fname.size);
+         pDev->pcoreOmni->cServer[fname.size] = '\0';
+         fprintf (stderr, "Utilizing Server - %s \n", pDev->pcoreOmni->cServer);;
+         pDev->iUseServer = 1;
+      }
    }                                                                //@@05092001
 
    /*
     *  Set user options for dialog function
     */
-
    fname = deffname;                                                //@@05092001
-   iReturnCode = param_read_string(plist,"jobdialog",&fname);  //@@05092001
+   iReturnCode = param_read_string(plist,"jobdialog",&fname);       //@@05092001
 
-   if(0 > iReturnCode)                                              //@@05092001
+   if (0 > iReturnCode)                                             //@@05092001
    {                                                                //@@05092001
-      if(iReturnCode < 0)                                           //@@05092001
+      if (iReturnCode < 0)                                          //@@05092001
       {                                                             //@@05092001
-          iReturnCode = param_read_null(plist,"jobdialog");     //@@05092001
-          if(iReturnCode != 0)                                      //@@05092001
-            fprintf(stderr, "Error Reading server parameter\n");    //@@05092001
+         iReturnCode = param_read_null(plist,"jobdialog");          //@@05092001
+         if (iReturnCode != 0)                                      //@@05092001
+            fprintf(stderr, "Error Reading jobdialog parameter\n"); //@@05092001
       }                                                             //@@05092001
    }                                                                //@@05092001
    else                                                             //@@05092001
    {                                                                //@@05092001
-       if( !iReturnCode) 
-       {
-           if (fDebugOutput) fprintf(stderr, "Utilizing dialog\n");   
-           pDev->iUseDialog = 1;                                            
-       }
-
+      if (!iReturnCode)
+      {
+         if (fDebugOutput) fprintf(stderr, "Utilizing dialog\n");
+            pDev->iUseDialog = 1;
+      }
    }                                                                //@@05092001
 
-   if(pDev->iSetup != 1)
+   if (pDev->iSetup != 1)
    {
       // create a device based on the user supplied inputs
       // To-Do - free the device
 
       if (fDebugOutput) fprintf(stderr,"setting following options on CreateDevice\n");
-      if (fDebugOutput) fprintf(stderr,"DeviceName= %s\n", pDev->pcoreOmni->cDeviceName );
-      if (fDebugOutput) fprintf(stderr,"%s\n", pDev->pcoreOmni->pszJobOptions);
+      if (fDebugOutput) fprintf(stderr,"DeviceName = %s\n", pDev->pcoreOmni->cDeviceName );
+      if (fDebugOutput) fprintf(stderr,"pszJobOptions = %s\n", pDev->pcoreOmni->pszJobOptions);
       if (fDebugOutput) fprintf(stderr,"debug parameter = %s \n", pDev->pcoreOmni->cDebugFile );
 
       /*
        *  Create a device definition by using the input parameters as the
        *  the defining factors
        */
-
       if (!pDev->pcoreOmni->cDeviceName[0])
       {
-          bRet = gdev_prn_put_params ((gx_device *)prgxdev, plist);
-          return bRet;
+         bRet = gdev_prn_put_params ((gx_device *)prgxdev, plist);
+
+         return bRet;
       }
 
-      // Removed following code so commandline server invocation is
-      // just -sserver  @@01302002
+      if (  !pDev->pcoreOmni->pszJobOptions
+         && pDev->iUseDialog
+         )
+      {
+         int                       iLength                  = 0;
+         char                     *pszSelectedJobProperties;
+         PFNGETOMNIJOBPROPERTIES   pfnJobDialog;
+         PFNFREEOMNIJOBPROPERTIES  pfnFreeDialogMemory;
+         GModule                  *pModule                  = 0;
 
-//      if(pDev->iUseServer && pDev->cServerFile[0])                  //@@05092001
-//      {                                                             //@@05092001
-//                                                                    //@@05092001
-//        pDev->ProxyFile = fopen(pDev->cServerFile, "wb");           //@@05092001
-//                                                                    //@@05092001
-//      }                                                             //@@05092001
-
-/*****************************************************************/
-   if(!pDev->pcoreOmni->pszJobOptions && pDev->iUseDialog)
-   {
-		
-	 int iLength=0;
-     char *pszSelectedJobProperties;
-     int (*pfnJobDialog) (char[] , char **);
-     int (*pfnFreeDialogMemory) (char **);
-
-
-	 GModule *pModule = 0; 
-     for (i = 0; i < 4 && !pModule; i++)
-     {
-         pszDeviceLib = (char *)gs_malloc (1, strlen (cDialogName)
-                                          + strlen (apszLibraryPaths[i])
-                                          + 1, "Devicestring");
-         pszDeviceLib[0] = '\0';
+         for (i = 0; i < sizeof (apszLibraryPaths)/sizeof (apszLibraryPaths[0]) && !pModule; i++)
+         {
+            pszDeviceLib = (char *)gs_malloc (1,
+                                              strlen (cDialogName)
+                                              + strlen (apszLibraryPaths[i])
+                                              + 1,
+                                              "Devicestring");
+            pszDeviceLib[0] = '\0';
+
+            if (pszDeviceLib)
+            {
+                sprintf (pszDeviceLib, "%s%s", apszLibraryPaths[i], cDialogName);
+
+                if (fDebugOutput) fprintf (stderr, "attempting to load - %s\n", pszDeviceLib);
+
+                pModule = g_module_open (pszDeviceLib, (GModuleFlags)0);
+            }
+            gs_free (pszDeviceLib, strlen (pszDeviceLib) + 1, 1, "Devicestring");
+         }
 
-         if (pszDeviceLib)
+         if (!pModule)
          {
-             sprintf (pszDeviceLib, "%s%s", apszLibraryPaths[i], cDialogName);
-             if (fDebugOutput) fprintf (stderr, "attempting to load - %s\n", pszDeviceLib);
-             pModule = g_module_open(pszDeviceLib,(GModuleFlags)0); 
+            fprintf(stderr, "Unable to open <<%s>>.", cDialogName);
          }
-         gs_free (pszDeviceLib,strlen(pszDeviceLib)+1, 1, "Devicestring");
-     }
+         else
+         {
+            g_module_symbol (pModule, "GetOmniJobProperties", (gpointer *)&pfnJobDialog);
 
-     if(!pModule)
-     {
-       fprintf(stderr, "Unable to open <<%s>>.",cDialogName);
-	 }
-	 else
-	 {       
-       g_module_symbol(pModule, "GetOmniJobProperties", (gpointer *) &pfnJobDialog);
-       if(pfnJobDialog)
-       {
-           pfnJobDialog(pDev->pcoreOmni->cDeviceName, &pszSelectedJobProperties);
-           iLength = strlen(pszSelectedJobProperties);
-           if(!pDev->pcoreOmni->pszJobOptions)
-                pDev->pcoreOmni->pszJobOptions = (char *)gs_malloc(1,iLength+1,"Option String");
-
-           strcpy(pDev->pcoreOmni->pszJobOptions, pszSelectedJobProperties);
-
-           if (fDebugOutput) fprintf(stderr, "options = %s\n", pDev->pcoreOmni->pszJobOptions);
-
-           g_module_symbol(pModule, "FreeOmniJobProperties", (gpointer *) &pfnFreeDialogMemory);
-           if(pfnFreeDialogMemory)
-           {
-               pfnFreeDialogMemory(&pszSelectedJobProperties); 
-               if (fDebugOutput) fprintf(stderr, "Freeing Dialog Memory\n");
-           }
+            if (pfnJobDialog)
+            {
+               pfnJobDialog(pDev->pcoreOmni->cDeviceName, &pszSelectedJobProperties);
 
+               iLength = strlen(pszSelectedJobProperties);
 
-       }
-	 }
+               if (!pDev->pcoreOmni->pszJobOptions)
+                  pDev->pcoreOmni->pszJobOptions = (char *)gs_malloc(1, iLength + 1, "Option String");
 
-   }	 
-/**********************************************************************/      
+               strcpy (pDev->pcoreOmni->pszJobOptions, pszSelectedJobProperties);
 
-      if(pDev->iUseServer)
-      {
-          pDev->pcoreOmni->bPDCDevice = true;  
-          if (fDebugOutput) fprintf(stderr, "utilizing server\n");
-      }
-      else
-          pDev->pcoreOmni->bPDCDevice = false;  
+               if (fDebugOutput) fprintf(stderr, "options = %s\n", pDev->pcoreOmni->pszJobOptions);
 
-      pDev->pcoreOmni->pDevice = pDev->pfnCreateDevice(pDev->pcoreOmni->cDeviceName,
-                                                       pDev->pOutputObject,
-                                                      &pDev->hmodDevice,
-                                                       pDev->pcoreOmni->cDebugFile,
-                                                       pDev->pcoreOmni->pszJobOptions,
-                                                       pDev->iUseServer,       //@@05092001
-                                                       pDev->ProxyFile);       //@@05092001
+               g_module_symbol(pModule, "FreeOmniJobProperties", (gpointer *)&pfnFreeDialogMemory);
 
+               if (pfnFreeDialogMemory)
+               {
+                  pfnFreeDialogMemory (&pszSelectedJobProperties);
 
+                  if (fDebugOutput) fprintf(stderr, "Freeing Dialog Memory\n");
+               }
+            }
+         }
+      }
 
-      if (!pDev->pcoreOmni->pDevice)
+      if (pDev->iUseServer)
       {
-         return_error(gs_error_Fatal);  // fail if no device was created
+         pDev->pcoreOmni->bPDCDevice = true;
       }
-      else
+
+      // get the omni version in case we need it
+      if (pDev->pfnGIInit)
       {
-          if (fDebugOutput) fprintf(stderr,"Device = %s ", pDev->pcoreOmni->cDeviceName );
-          if(pDev->pcoreOmni->bPDCDevice) 
-              pDev->pcoreOmni->pPDCDevice = pDev->pcoreOmni->pDevice;
-      }
-           // get the omni version in case we need it
-      if(pDev->pfnGetVersion)
-      {
-         pDev->pfnGetVersion((void*) pDev->pcoreOmni, pDev->pcoreOmni->cOmniVersion);
-         if (fDebugOutput) fprintf(stderr, "Omni version = %s \n",pDev->pcoreOmni->cOmniVersion );
-         pDev->pCallPtr = (void *) pDev->pcoreOmni;
+         pDev->pfnGIInit ((void*)pDev->pcoreOmni);
+
+         if (fDebugOutput) fprintf(stderr, "core_omni_device size = %d\n",pDev->pcoreOmni->cbSize);
+         if (fDebugOutput) fprintf(stderr, "GI version = %s\n",pDev->pcoreOmni->cVersion);
+
+         pDev->pCallPtr = (void *)pDev->pcoreOmni;
       }
       else
       {
-          pDev->pCallPtr = (void *) pDev->pcoreOmni->pDevice ;
+         pDev->pCallPtr = (void *)pDev->pcoreOmni->pDevice;
       }
 
+      pDev->pcoreOmni->pDevice = pDev->pfnCreateDevice (pDev->pcoreOmni,
+                                                        (void **)&pDev->hmodDevice,
+                                                        pDev->iUseServer);
 
-      bRet = pDev->pfnGetPrintModeInfo ((void*) pDev->pCallPtr, &prtMode);
+      if (!pDev->pcoreOmni->pDevice)
+      {
+         fprintf (stderr, "Unable create a omni device\n");
 
-      if(bRet)
-      {          // turn off Ghostscript mono if we are not in mono mode
-          if((prtMode.iBitCount > 1) && pDev->iGSMono )
-          {
-              if (fDebugOutput) fprintf (stderr, "Turning off GSMONO - prtMode.iBitCount = %d\n", prtMode.iBitCount);
-              pDev->iGSMono = 0;
-          }
+         return_error (gs_error_Fatal);  // fail if no device was created
+      }
+
+      if (fDebugOutput) fprintf (stderr, "Device = %08X\n", (unsigned int)pDev->pcoreOmni->pDevice);
+      if (fDebugOutput) fprintf (stderr, "Omni version = %s\n", pDev->pcoreOmni->cOmniVersion);
+      if (fDebugOutput) fprintf (stderr, "Device = \"%s\"\n", pDev->pcoreOmni->cDeviceName);
+
+      bRet = pDev->pfnGetPrintModeInfo ((void*)pDev->pCallPtr, &prtMode);
+
+      if (fDebugOutput) fprintf(stderr, "GetPrintModeInfo returns %d\n",bRet);
+      if (fDebugOutput) fprintf(stderr, "GetPrintModeInfo.iBitCount = %d\n",prtMode.iBitCount);
+      if (fDebugOutput) fprintf(stderr, "GetPrintModeInfo.iPlanes = %d\n",prtMode.iPlanes);
+
+      if (bRet)
+      {
+         // turn off Ghostscript mono if we are not in mono mode
+         if (  (prtMode.iBitCount > 1)
+            && pDev->iGSMono
+            )
+         {
+            if (fDebugOutput) fprintf (stderr, "Turning off GSMONO - prtMode.iBitCount = %d\n", prtMode.iBitCount);
+            pDev->iGSMono = 0;
+         }
       }
                          //** this routine is called multiple times
       pDev->iSetup = 1;  //** don't go setting up new devices
-      
+
       // get the hardware resolution information
-      
-      bRet = pDev->pfnGetResolutionInfo ((void*) pDev->pCallPtr, &hwRes);
 
-      if(!bRet)
-          return_error(gs_error_Fatal);
+      bRet = pDev->pfnGetResolutionInfo ((void*)pDev->pCallPtr, &hwRes);
+
+      if (!bRet)
+         return_error(gs_error_Fatal);
 
       // get the hardware page margins information
 
-      bRet = pDev->pfnGetMarginInfo ((void*) pDev->pCallPtr, &hwMargins);
-      
-      if(!bRet)
-          return_error(gs_error_Fatal);
+      bRet = pDev->pfnGetMarginInfo ((void*)pDev->pCallPtr, &hwMargins);
+
+      if (fDebugOutput) fprintf (stderr, "GetMarginInfo returns %d\n", bRet);
+      if (fDebugOutput) fprintf (stderr, "GetMarginInfo.fLeftClip = %f\n", hwMargins.fLeftClip);
+      if (fDebugOutput) fprintf (stderr, "GetMarginInfo.fBottomClip = %f\n", hwMargins.fBottomClip);
+      if (fDebugOutput) fprintf (stderr, "GetMarginInfo.fRightClip = %f\n", hwMargins.fRightClip);
+      if (fDebugOutput) fprintf (stderr, "GetMarginInfo.fTopClip = %f\n", hwMargins.fTopClip);
+      if (fDebugOutput) fprintf (stderr, "GetMarginInfo.fxWidth = %f\n", hwMargins.fxWidth);
+      if (fDebugOutput) fprintf (stderr, "GetMarginInfo.fyHeight = %f\n", hwMargins.fyHeight);
+
+      if (!bRet)
+         return_error(gs_error_Fatal);
 
       /*
        *  We have to let GS know about our page and resolution parameters
@@ -1210,9 +1194,10 @@
       if (fDebugOutput) fprintf(stderr, "right margin pts  = %f \n", prgxdev->HWMargins[2]);    //@@05092001A
       if (fDebugOutput) fprintf(stderr, "top margin pts    = %f \n", prgxdev->HWMargins[3]);    //@@05092001A
 
-      if(!pDev->iGSMono)                       //@@04252001
-      {            //1,1,1,0,2,0 - mono        //@@04252001
-                   //3, 24,255,255,5,5 -  color //@@04252001
+      if (!pDev->iGSMono)
+      {
+         // 1,1,1,0,2,0       - mono  //@@04252001
+         // 3, 24,255,255,5,5 - color //@@04252001
          if (fDebugOutput) fprintf(stderr, "depth = %d \n", prgxdev->color_info.depth              );   //@@04252001
          if (fDebugOutput) fprintf(stderr, "num_comp = %d \n", prgxdev->color_info.num_components  );   //@@04252001
          if (fDebugOutput) fprintf(stderr, "max_gray = %d \n", prgxdev->color_info.max_gray        );   //@@04252001
@@ -1220,197 +1205,201 @@
          if (fDebugOutput) fprintf(stderr, "dither_grays = %d \n", prgxdev->color_info.dither_grays   );//@@04252001
          if (fDebugOutput) fprintf(stderr, "dither_colors = %d \n", prgxdev->color_info.dither_colors );//@@04252001
                                                                                                         //@@04252001
-          prgxdev->color_info.depth          = 24;                                                      //@@04252001
-          prgxdev->color_info.num_components = 3;                                                       //@@04252001
-          prgxdev->color_info.max_gray       = 255;                                                     //@@04252001
-          prgxdev->color_info.max_color      = 255;                                                     //@@04252001
-          prgxdev->color_info.dither_grays   = 5;                                                       //@@04252001
-          prgxdev->color_info.dither_colors  = 5;                                                       //@@04252001
+         prgxdev->color_info.depth          = 24;                                                      //@@04252001
+         prgxdev->color_info.num_components = 3;                                                       //@@04252001
+         prgxdev->color_info.max_gray       = 255;                                                     //@@04252001
+         prgxdev->color_info.max_color      = 255;                                                     //@@04252001
+         prgxdev->color_info.dither_grays   = 5;                                                       //@@04252001
+         prgxdev->color_info.dither_colors  = 5;                                                       //@@04252001
       }
-   }                                                            // column size
+   }
 
    iReturnCode = gdev_prn_put_params((gx_device *)prgxdev, plist);
 
    return iReturnCode;  // likely not be a failure
 }
 
-
-
 private int
-omni_print_page(gx_device_printer * pdev, FILE * prn_stream)
+omni_print_page(gx_device_printer *pdev, FILE *prn_stream)
 {
-  static int iNumCopies = 1;
-  return PrintPage(pdev, prn_stream, iNumCopies);
+   return PrintPage (pdev, prn_stream, 1);
 }
+
 /* ------------------------------------------------------*/
 /* ------------------------------------------------------*/
 
 private int
-PrintPage(gx_device_printer *pgx_prt_dev, FILE *prn_stream, int num_copies)
+PrintPage (gx_device_printer *pgx_prt_dev, FILE *prn_stream, int num_copies)
 {
-    gx_device_omni * const pasyncDev = (gx_device_omni *)pgx_prt_dev;
-    gx_device * const pgx_dev = (gx_device *)pgx_prt_dev;
-    uint uiLineSize = gdev_prn_raster(pgx_prt_dev);  /* Raster line size  in bytes*/
-                                          /* BMP scan lines need to be padded to 32 bits. */
-    /*
-     * The following variables are uses for outputting the bitmap information
-     */
-
-    uint uiBytesPerLine = uiLineSize + (-uiLineSize & 3);  //actual raster line size used for row
-
-    byte * pBitmapMem = NULL;      // bitmap memory for the bitmap band
-    bool bRet;
-    RECTL rectPageLocation;
-    SIZEL sizelPage;
-    ULONG ulBandLength;            // number of scan-lines to match the memory threshold for a band
-    int   iBytesToAlloc;
-
-    int iYBand;
-    int code = 0;
-    int y, iNumColors;
-    byte *pGSData = 0;
-    byte *raster_data;
-
-    // MONO
-    byte *pMonoData = NULL;
-    DIFFUSIONDITHERINFO DiffInfo;
-    byte *pBuffer = NULL;
-    IMAGEINFOS ImageInfo;
-    POINTL ptlBounds= {0,0};
-    POINTL ptlTrgBounds= {0,0};
-
-    PRINTMODE prtMode;  //definition of printed output Bpp ..
-
-    // Get things setup to call into the driver code
-    BITMAPINFO2 *pbmi;
-
-
-    pDevStruct pDev = pasyncDev->pDev;
-
-    // Do a new_frame if not first page
-
-    if(!pDev || !pDev->pcoreOmni->pDevice )
-    {
-        fprintf(stderr, "\n<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n\n");
-        fprintf(stderr, "Error: -sDeviceName=XXX is not specified!\n\n");
-        return_error(gs_error_Fatal);
-    }
-
-    pDev->iPage++;
-    pDev->iPageNumber++;  //keep track of the page @@04162001
-
-    bRet = pDev->pfnGetPrintModeInfo ((void*) pasyncDev->pDev->pCallPtr, &prtMode);
-
-    iNumColors = 1 << prtMode.iBitCount;
-
-    // Allocate a full bitmapinfo2 and bitmap header message
-    iBytesToAlloc = sizeof (BITMAPINFO2);
-    if (256 >= iNumColors)
-    {
-        iBytesToAlloc += (iNumColors - 1) * sizeof (RGB2);
-    }
-
-    pbmi = (PBITMAPINFO2)gs_malloc(1, iBytesToAlloc, "Bmpi Memory");
-    if(!pbmi)
-    {
-        fprintf(stderr, "<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n");
-        fprintf(stderr, "   Failed allocation of pbmi in PrintPage\n");
-        return_error(gs_error_VMerror);
-    }
-
-    pbmi->cbFix = sizeof(BITMAPINFO2); /* Length of fixed portion of structure?? */
-
-    if (256 >= iNumColors)  // must be 16 or 24 bit
-    {
-        if(iNumColors == 2)
-        {
-
-            memset(&DiffInfo, 0xFF, sizeof(DiffInfo) );
-            memset(&ImageInfo, 0xFF, sizeof(ImageInfo) );
-
-            DiffInfo.ulLength = sizeof(DiffInfo);
-            DiffInfo.ulType = GDM_MATRIX_DITHER;
-            DiffInfo.fOptions    =  0;
-            DiffInfo.ulIntensity = 80;
-            DiffInfo.bRedWt      = 30; //25
-            DiffInfo.bGreenWt    = 50; //60
-            DiffInfo.bBlueWt     = 20; //15
-            DiffInfo.bPad        =  0;
-
-            if(!pDev->iGSMono)                                         //@@04252001
-            {                                                          //@@04252001
-                pbmi->argbColor[0].bBlue  = 0xFF;  // background       //@@04252001
-                pbmi->argbColor[0].bRed   = 0xFF;                      //@@04252001
-                pbmi->argbColor[0].bGreen = 0xFF;                      //@@04252001
-                pbmi->argbColor[1].bBlue  = 0x00;   // foreground      //@@04252001
-                pbmi->argbColor[1].bRed   = 0x00;                      //@@04252001
-                pbmi->argbColor[1].bGreen = 0x00;                      //@@04252001
-            }                                                          //@@04252001
-            else                                                       //@@04252001
-            {                                                          //@@04252001
-                pbmi->argbColor[1].bBlue  = 0xFF;  // background       //@@04252001
-                pbmi->argbColor[1].bRed   = 0xFF;                      //@@04252001
-                pbmi->argbColor[1].bGreen = 0xFF;                      //@@04252001
-                pbmi->argbColor[0].bBlue  = 0x00;   // foreground      //@@04252001
-                pbmi->argbColor[0].bRed   = 0x00;                      //@@04252001
-                pbmi->argbColor[0].bGreen = 0x00;                      //@@04252001
-            }                                                          //@@04252001
-
-            ImageInfo.pptlSrc             = &ptlBounds;    // rectangle extents
-            ImageInfo.pptlDst             = &ptlTrgBounds;    // rectangle extents
-            ImageInfo.ulSrcBpp            = 24;
-            ImageInfo.ulSrcBytesPerLine   = uiBytesPerLine;   // src bytes per line
-            ImageInfo.ulcSrcClrs          = 0;
-            ImageInfo.ulSrcClrType        = 0;
-            ImageInfo.pargb2Src           = 0;         // if srcBPP != 24
-            ImageInfo.ulTrgBpp            = 1;
-            ImageInfo.ulTrgBytesPerLine   = pasyncDev->width + (-pasyncDev->width & 31);
-            ImageInfo.ulTrgBytesPerLine  /= 8;
-            ImageInfo.ulcTrgClrs          = 2;
-            ImageInfo.ulTrgClrType        = 0;
-            ImageInfo.pargb2Trg           = NULL;
-            ImageInfo.ulOptions           = 0;            // options
-            ImageInfo.ulPelSizeCorrection = pDev->ulPelSizeCorrection;
-
-            ptlBounds.x = pasyncDev->width;             // Bounding rectangle for input bitmap
-            ptlTrgBounds.x = pasyncDev->width;          // Bounding rectangle for output bitmap
-
-        }
-        else
-        {
-            /*
-             * add for 256 color support -- TBD...
-             */
-        }
-
-    }
-    /* set the bitmap width to match the page */
-
-    pbmi->cx = pgx_prt_dev->width;
-
-    if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
-    if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
-    if (fDebugOutput) fprintf(stderr, "ulTrgBytesPerLine = %ld \n",ImageInfo.ulTrgBytesPerLine );
-    if (fDebugOutput) fprintf(stderr, "ulBytesPerLine = %d \n",uiBytesPerLine );
-    if (fDebugOutput) fprintf(stderr, "ulLineSize = %d \n",uiLineSize );
-    if (fDebugOutput) fprintf(stderr, "         width = %d \n  height = %d \n", pgx_prt_dev->width, pgx_prt_dev->height);
-    if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
-    if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
-
-    pbmi->cPlanes   = prtMode.iPlanes;   /* Number of bit planes                   */
-    pbmi->cBitCount = prtMode.iBitCount; /*  number of bits per pel                */
-
-    /*
-     * BMP format is single page, so discard all but 1st printable page
-     * This logic isn't quite right, since we can't truncate file if
-     * num_pages == 0.
-     */
-    if(pasyncDev->copies_printed > 0)
-      return 0;
+   gx_device_omni * const pasyncDev        = (gx_device_omni *)pgx_prt_dev;
+   gx_device * const      pgx_dev          = (gx_device *)pgx_prt_dev;
+   uint                   uiLineSize       = gdev_prn_raster (pgx_prt_dev);  /* Raster line size  in bytes*/
+
+   /* BMP scan lines need to be padded to 32 bits. */
+
+   /*
+    * The following variables are uses for outputting the bitmap information
+    */
+   uint                   uiBytesPerLine   = uiLineSize + (-uiLineSize & 3);  //actual raster line size used for row
+
+   byte                  *pBitmapMem       = NULL;   // bitmap memory for the bitmap band
+   bool                   bRet;
+   RECTL                  rectPageLocation;
+   SIZEL                  sizelPage;
+   ULONG                  ulBandLength;              // number of scan-lines to match the memory threshold for a band
+   int                    iBytesToAlloc;
+
+   int                    iYBand;
+   int                    code             = 0;
+   int                    y,
+                          iNumColors;
+   byte                  *pGSData          = 0;
+   byte                  *raster_data;
+
+   // MONO
+   byte                  *pMonoData        = NULL;
+   DIFFUSIONDITHERINFO    DiffInfo;
+   byte                  *pBuffer          = NULL;
+   IMAGEINFOS             ImageInfo;
+   POINTL                 ptlBounds;
+   POINTL                 ptlTrgBounds;
+
+   PRINTMODE              prtMode;                   // definition of printed output Bpp ..
+
+   // Get things setup to call into the driver code
+   BITMAPINFO2           *pbmi;
+
+   PDEVSTRUCT             pDev             = pasyncDev->pDev;
+
+   ptlBounds.x    = 0;
+   ptlBounds.y    = 0;
+   ptlTrgBounds.x = 0;
+   ptlTrgBounds.y = 0;
+
+   // Do a new_frame if not first page
+
+   if (  !pDev
+      || !pDev->pcoreOmni->pDevice
+      )
+   {
+      fprintf (stderr, "\n<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n\n");
+      fprintf (stderr, "Error: -sDeviceName=XXX is not specified!\n\n");
+
+      return_error(gs_error_Fatal);
+   }
+
+   pDev->iPage++;
+   pDev->iPageNumber++;  //keep track of the page @@04162001
+
+   bRet = pDev->pfnGetPrintModeInfo ((void*)pasyncDev->pDev->pCallPtr, &prtMode);
+
+   iNumColors = 1 << prtMode.iBitCount;
+
+   // Allocate a full bitmapinfo2 and bitmap header message
+   iBytesToAlloc = sizeof (BITMAPINFO2);
+   if (256 >= iNumColors)
+   {
+      iBytesToAlloc += (iNumColors - 1) * sizeof (RGB2);
+   }
+
+   pbmi = (PBITMAPINFO2)gs_malloc (1, iBytesToAlloc, "Bmpi Memory");
+   if(!pbmi)
+   {
+      fprintf(stderr, "<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n");
+      fprintf(stderr, "   Failed allocation of pbmi in PrintPage\n");
+
+      return_error(gs_error_VMerror);
+   }
+
+   pbmi->cbFix = sizeof(BITMAPINFO2); /* Length of fixed portion of structure?? */
+
+   if (256 >= iNumColors)  // must be 16 or 24 bit
+   {
+      if (iNumColors == 2)
+      {
+         memset (&DiffInfo, 0xFF, sizeof (DiffInfo));
+         memset (&ImageInfo, 0xFF, sizeof (ImageInfo));
+
+         DiffInfo.ulLength    = sizeof (DiffInfo);
+         DiffInfo.ulType      = GDM_MATRIX_DITHER;
+         DiffInfo.fOptions    =  0;
+         DiffInfo.ulIntensity = 80;
+         DiffInfo.bRedWt      = 30; //25
+         DiffInfo.bGreenWt    = 50; //60
+         DiffInfo.bBlueWt     = 20; //15
+         DiffInfo.bPad        =  0;
+
+         if (!pDev->iGSMono)                                       //@@04252001
+         {                                                         //@@04252001
+            pbmi->argbColor[0].bBlue  = 0xFF;  // background       //@@04252001
+            pbmi->argbColor[0].bRed   = 0xFF;                      //@@04252001
+            pbmi->argbColor[0].bGreen = 0xFF;                      //@@04252001
+            pbmi->argbColor[1].bBlue  = 0x00;  // foreground       //@@04252001
+            pbmi->argbColor[1].bRed   = 0x00;                      //@@04252001
+            pbmi->argbColor[1].bGreen = 0x00;                      //@@04252001
+         }                                                         //@@04252001
+         else                                                      //@@04252001
+         {                                                         //@@04252001
+            pbmi->argbColor[1].bBlue  = 0xFF;  // background       //@@04252001
+            pbmi->argbColor[1].bRed   = 0xFF;                      //@@04252001
+            pbmi->argbColor[1].bGreen = 0xFF;                      //@@04252001
+            pbmi->argbColor[0].bBlue  = 0x00;  // foreground       //@@04252001
+            pbmi->argbColor[0].bRed   = 0x00;                      //@@04252001
+            pbmi->argbColor[0].bGreen = 0x00;                      //@@04252001
+         }                                                         //@@04252001
+
+         ImageInfo.pptlSrc             = &ptlBounds;       // rectangle extents
+         ImageInfo.pptlDst             = &ptlTrgBounds;    // rectangle extents
+         ImageInfo.ulSrcBpp            = 24;
+         ImageInfo.ulSrcBytesPerLine   = uiBytesPerLine;   // src bytes per line
+         ImageInfo.ulcSrcClrs          = 0;
+         ImageInfo.ulSrcClrType        = 0;
+         ImageInfo.pargb2Src           = 0;                // if srcBPP != 24
+         ImageInfo.ulTrgBpp            = 1;
+         ImageInfo.ulTrgBytesPerLine   = pasyncDev->width + (-pasyncDev->width & 31);
+         ImageInfo.ulTrgBytesPerLine  /= 8;
+         ImageInfo.ulcTrgClrs          = 2;
+         ImageInfo.ulTrgClrType        = 0;
+         ImageInfo.pargb2Trg           = NULL;
+         ImageInfo.ulOptions           = 0;            // options
+         ImageInfo.ulPelSizeCorrection = pDev->ulPelSizeCorrection;
+
+         ptlBounds.x = pasyncDev->width;             // Bounding rectangle for input bitmap
+         ptlTrgBounds.x = pasyncDev->width;          // Bounding rectangle for output bitmap
+      }
+      else
+      {
+         /*
+          * add for 256 color support -- @TBD ...
+          */
+      }
+   }
+   /* set the bitmap width to match the page */
 
-   if(pDev->iSync)
+   pbmi->cx = pgx_prt_dev->width;
+
+   if (fDebugOutput) fprintf (stderr, "***************************************************************\n");
+   if (fDebugOutput) fprintf (stderr, "ulTrgBytesPerLine = %ld\n", ImageInfo.ulTrgBytesPerLine);
+   if (fDebugOutput) fprintf (stderr, "ulBytesPerLine = %d\n", uiBytesPerLine);
+   if (fDebugOutput) fprintf (stderr, "ulLineSize = %d\n", uiLineSize);
+   if (fDebugOutput) fprintf (stderr, "width = %d\n", pgx_prt_dev->width);
+   if (fDebugOutput) fprintf (stderr, "height = %d\n", pgx_prt_dev->height);
+   if (fDebugOutput) fprintf (stderr, "***************************************************************\n");
+
+   pbmi->cPlanes   = prtMode.iPlanes;   /* Number of bit planes                   */
+   pbmi->cBitCount = prtMode.iBitCount; /*  number of bits per pel                */
+
+   /*
+    * BMP format is single page, so discard all but 1st printable page
+    * This logic isn't quite right, since we can't truncate file if
+    * num_pages == 0.
+    */
+   if (pasyncDev->copies_printed > 0)
+     return 0;
+
+   if (pDev->iSync)
    {
-    /* If there's data in buffer, need to process w/overlays */
+      /* If there's data in buffer, need to process w/overlays */
       if (pasyncDev->buffered_page_exists)
       {
          code = BufferPage(pgx_prt_dev, prn_stream, num_copies);
@@ -1418,82 +1407,84 @@
       }
    }
 
-   pGSData = (byte *)gs_malloc(uiBytesPerLine, 1, "bmp file buffer");
+   pGSData = (byte *)gs_malloc (uiBytesPerLine, 1, "bmp file buffer");
 
-   if(pGSData == 0)  /* can't allocate row buffer */
-      return_error(gs_error_VMerror);
+   if (pGSData == 0)
+      /* can't allocate row buffer */
+      return_error (gs_error_VMerror);
 
-    /* seek to the file's end */
-   if(pDev->iPage == 1)
+   /* seek to the file's end */
+   if (pDev->iPage == 1)
    {
-       fseek(prn_stream, 0L, SEEK_SET);
+      fseek (prn_stream, 0L, SEEK_SET);
    }
 
    // need to calculate the correct bandsize needed for the device
-   ulBandLength = FindBandSize(pasyncDev->height, pasyncDev->width,
-                               //pbmi->cBitCount,
-                               24,       // always use 24 bits for source bitmap
-                               pbmi->cPlanes,
-                               pasyncDev->pDev->iVertDots,
-                               8000*1024);      //eight meg buffer
+   ulBandLength = FindBandSize (pasyncDev->height,
+                                pasyncDev->width,
+////////////////////////////////pbmi->cBitCount,
+                                24,                         // always use 24 bits for source bitmap
+                                pbmi->cPlanes,
+                                pasyncDev->pDev->iVertDots,
+                                8000*1024);                 //eight meg buffer
+
+   pBitmapMem = (byte *) gs_malloc (1, uiBytesPerLine * ulBandLength, "Bitmap Memory");
 
-   pBitmapMem = (byte *) gs_malloc(1, uiBytesPerLine * ulBandLength, "Bitmap Memory");
    if(!pBitmapMem)
    {
-       fprintf(stderr, "<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n");
-       fprintf(stderr, "   Failed allocation of pBitmapMem in PrintPage\n");
-       return_error(gs_error_VMerror);
+      fprintf (stderr, "<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n");
+      fprintf (stderr, "   Failed allocation of pBitmapMem in PrintPage\n");
+
+      return_error (gs_error_VMerror);
    }
 
-    // is the band bigger than the page ?
+   // is the band bigger than the page ?
 
-   sizelPage.cx   = pasyncDev->width;
-   sizelPage.cy   = pasyncDev->height;
+   sizelPage.cx = pasyncDev->width;
+   sizelPage.cy = pasyncDev->height;
 
    ulBandLength = ulBandLength >=sizelPage.cy ? sizelPage.cy : ulBandLength;
 
-   if(pBitmapMem)
-      memset(pBitmapMem, 0xFF, uiBytesPerLine * ulBandLength ); // memset the memory to white? maybe zero
-   else
+   if (pBitmapMem)
    {
-       fprintf(stderr, "<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n");
-       fprintf(stderr, "            Bitmap memory alloc Failed \n");
-       return_error(gs_error_VMerror);
+      memset (pBitmapMem, 0xFF, uiBytesPerLine * ulBandLength ); // memset the memory to white? maybe zero
    }
+   else
+   {
+      fprintf(stderr, "<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n");
+      fprintf(stderr, "            Bitmap memory alloc Failed \n");
 
+      return_error (gs_error_VMerror);
+   }
 
    // Do initial setup for Rasterize for dithering work on the page.
 
-   rectPageLocation.xLeft    = 0;
+   rectPageLocation.xLeft  = 0;
+   rectPageLocation.xRight = pasyncDev->width;
 
-   rectPageLocation.xRight   = pasyncDev->width;
    //@@04162001
-   if(pDev->iPageNumber == 1)
+   if (pDev->iPageNumber == 1)
    {
-       pDev->pcoreOmni->pfile = prn_stream;
-
-       pDev->pfnBeginJob ((void*) pasyncDev->pDev->pCallPtr, prn_stream);
+      pDev->pcoreOmni->pfpOut = prn_stream;
 
-          // copy the PDC pointer to the pDevice since pDevice is defaulted throughout code
-       if(pasyncDev->pDev->pcoreOmni->bPDCDevice)
-           pasyncDev->pDev->pcoreOmni->pDevice = pasyncDev->pDev->pcoreOmni->pPDCDevice;
+      pDev->pfnBeginJob ((void*)pasyncDev->pDev->pCallPtr, prn_stream);
    }
    else
-      pDev->pfnNewFrame ((void*) pasyncDev->pDev->pCallPtr);
-
+   {
+      pDev->pfnNewFrame ((void*)pasyncDev->pDev->pCallPtr);
+   }
 
 // rectPageLocation.yTop = rectPageLocation.yBottom  = 0;  @@10172000
-
-   rectPageLocation.yTop =  pasyncDev->height-1;       // @@10172000
+   rectPageLocation.yTop = pasyncDev->height-1;       // @@10172000
 
    /*
     *    Banding Implementation based on bandsize - need to put bits in place so that we can
     *    tell if this is a top to down or bottom to top printer.
     */
+   {
+      //BEGIN BLOCK for Banding code
 
-   {  //BEGIN BLOCK for Banding code
-
-//      int iCurTop = 0, iCurBot = 0;  @@10172000
+//    int iCurTop = 0, iCurBot = 0;  @@10172000
 
       /*
        *  Since this band needs to be flipped, we need to get a pointer to the top of memory
@@ -1507,175 +1498,191 @@
       iYBand = 0;
 
       // Call DiffusionDither to setup pBuffer - quick in and out  @@04062001
-      if(!pDev->iGSMono)          //@@04252001
-            pDev->pfnMonoDither (&DiffInfo, &ImageInfo, &pBuffer, (unsigned long) GDM_DITHER_BEGIN);
+      if (!pDev->iGSMono)          //@@04252001
+         pDev->pfnMonoDither (&DiffInfo,
+                              &ImageInfo,
+                              &pBuffer,
+                              (unsigned long)GDM_DITHER_BEGIN);
 
       // Go through the bitmap that we have been given
-      for(y = pasyncDev->height - 1; y >= 0; y--)
+      for (y = pasyncDev->height - 1; y >= 0; y--)
       {                                   //@@10312000
-         if ( (iYBand < ulBandLength) && ((code = dev_proc(pgx_dev, get_bits)(pgx_dev, pasyncDev->height - 1 - y, pGSData, &raster_data)) >= 0) && (y != 0))
+         if (  (iYBand < ulBandLength)
+            && ((code = dev_proc(pgx_dev, get_bits)(pgx_dev, pasyncDev->height - 1 - y, pGSData, &raster_data)) >= 0)
+            && (y != 0)
+            )
          {
-
-            memcpy(pBitmapTop - (iYBand  * uiBytesPerLine), raster_data, uiBytesPerLine);
+            memcpy (pBitmapTop - (iYBand  * uiBytesPerLine), raster_data, uiBytesPerLine);
 
             iYBand++;  // keep track of lines in the band
-
          }
          else
          {
-           if((code < 0) && (y > 0))  // add back in the line we failed to get if an error was returned
-           {                          // from get_bits
-               if(iYBand != ulBandLength)                                                    //@@10252000
+            if (  (code < 0)
+               && (y > 0)
+               )             // add back in the line we failed to get if an error was returned from get_bits
+            {
+               if (iYBand != ulBandLength)                                                    //@@10252000
                {
-                   y++;
-                   continue;
+                  y++;
+                  continue;
                }
-           }
-                // we always decrement y when we come through here even if this is just a complete band
-           if(iYBand == ulBandLength)      //@@10312000
+            }
+
+            // we always decrement y when we come through here even if this is just a complete band
+            if (iYBand == ulBandLength)      //@@10312000
                y++;
 
-           // we currently support 24bit or mono so if this is the mono case, allocate memory to be
-           // used for the gray-scaled bitmap buffer
-           if(!pDev->iGSMono)                    //@@04252001
-               if(prtMode.iBitCount < 16)
+            // we currently support 24bit or mono so if this is the mono case, allocate memory to be
+            // used for the gray-scaled bitmap buffer
+            if (!pDev->iGSMono)                    //@@04252001
+            {
+               if (prtMode.iBitCount < 16)
                {
-                   pMonoData = (byte *) gs_malloc(1, iYBand * ImageInfo.ulTrgBytesPerLine, "Mono Memory");
+                  pMonoData = (byte *)gs_malloc (1, iYBand * ImageInfo.ulTrgBytesPerLine, "Mono Memory");
 
-                   if(pMonoData)
-                       memset(pMonoData, 0xFF, iYBand * ImageInfo.ulTrgBytesPerLine );
-                   else
-                   {
-                       fprintf(stderr, "<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n");
-                       fprintf(stderr, "   Failed allocation of pMonoData in PrintPage\n");
-                       return_error(gs_error_VMerror);
-                   }
-
-                   ImageInfo.pptlSrc->y = ImageInfo.pptlDst->y = iYBand;//exclusive??
-                   ImageInfo.pbSrcBits  =  pBitmapTop - ((iYBand-1) * uiBytesPerLine);   // pointer to src image data
-                   ImageInfo.pbTrgBits  = pMonoData;        // pointer to dst image data
-
-                   // Call DiffusionDither to generate a gray-scaled image from our 24bit bitmap
-                   //@@04062001
-                   pDev->pfnMonoDither (&DiffInfo, &ImageInfo, &pBuffer, (unsigned long) 0);
+                  if (pMonoData)
+                  {
+                     memset(pMonoData, 0xFF, iYBand * ImageInfo.ulTrgBytesPerLine );
+                  }
+                  else
+                  {
+                     fprintf(stderr, "<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n");
+                     fprintf(stderr, "   Failed allocation of pMonoData in PrintPage\n");
+
+                     return_error(gs_error_VMerror);
+                  }
+
+                  ImageInfo.pptlSrc->y = ImageInfo.pptlDst->y = iYBand;               // exclusive??
+                  ImageInfo.pbSrcBits  = pBitmapTop - ((iYBand-1) * uiBytesPerLine);  // pointer to src image data
+                  ImageInfo.pbTrgBits  = pMonoData;                                   // pointer to dst image data
+
+                  // Call DiffusionDither to generate a gray-scaled image from our 24bit bitmap
+                  //@@04062001
+                  pDev->pfnMonoDither (&DiffInfo, &ImageInfo, &pBuffer, (unsigned long) 0);
                }
+            }
 
-           pbmi->cy = iYBand;
+            pbmi->cy = iYBand;
 
-           // set the page location to account for the new band size (cy)
+            // set the page location to account for the new band size (cy)
 
-//         rectPageLocation.yTop = iCurTop + pbmi->cy;  @@10172000
-           rectPageLocation.yBottom  = rectPageLocation.yTop - pbmi->cy ; // @@10172000
+////////////rectPageLocation.yTop = iCurTop + pbmi->cy;  @@10172000
+            rectPageLocation.yBottom  = rectPageLocation.yTop - pbmi->cy ; // @@10172000
 
-           // If this in a mono device, we need to send the mono data to the device and
-           // not the color
-
-           if(pMonoData && !pDev->iGSMono)//@@04252001
-           {
-              pDev->pfnRasterize ((void*) pasyncDev->pDev->pCallPtr,
-                                  pMonoData,
-                                  pbmi,
-                                  &sizelPage,
-                                  &rectPageLocation,
-                                  BITBLT_BITMAP);
-
-              // We're done with the mono band
-              // now free up the mono buffer so we can get clean data buffer if more lines are to be
-              // gray-scaled
-
-              gs_free((char *)pMonoData, iYBand * ImageInfo.ulTrgBytesPerLine, 1, "Mono Memory");
-              pMonoData = NULL;
-
-           }
-           else
-           {  // non-mono device -- Send the rgb bitmap to the dither and rasterize routines
-              if (fDebugOutput) fprintf(stderr, "rendering band lines %d - %d w/%d \n", (int)rectPageLocation.yTop, (int)rectPageLocation.yBottom, iYBand);
-
-              if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
-              if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
-              if (fDebugOutput) fprintf(stderr, "Number of lines in band = %d\n", iYBand);
-              if (fDebugOutput) fprintf(stderr, "rectPageLocation - Top = %ld\n", rectPageLocation.yTop);
-              if (fDebugOutput) fprintf(stderr, "rectPageLocation - Bot = %ld\n", rectPageLocation.yBottom);
-              if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
-              if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
-
-              pDev->pfnRasterize ((void*) pasyncDev->pDev->pCallPtr,
-                                  pBitmapTop - ((iYBand-1) * uiBytesPerLine),
-                                  pbmi,
-                                  &sizelPage,
-                                  &rectPageLocation,
-                                  BITBLT_BITMAP);
-                                                      // memset the memory to white
-              memset(pBitmapMem, 0xFF, uiBytesPerLine * ulBandLength );
-           }
+            // If this in a mono device, we need to send the mono data to the device and
+            // not the color
+
+            if (  pMonoData
+               && !pDev->iGSMono
+               ) //@@04252001
+            {
+               pDev->pfnRasterize ((void*)pasyncDev->pDev->pCallPtr,
+                                   pMonoData,
+                                   pbmi,
+                                   &sizelPage,
+                                   &rectPageLocation,
+                                   BITBLT_BITMAP);
+
+               // We're done with the mono band
+               // now free up the mono buffer so we can get clean data buffer if more lines are to be
+               // gray-scaled
+               gs_free ((char *)pMonoData, iYBand * ImageInfo.ulTrgBytesPerLine, 1, "Mono Memory");
+
+               pMonoData = NULL;
+            }
+            else
+            {  // non-mono device -- Send the rgb bitmap to the dither and rasterize routines
+               if (fDebugOutput) fprintf(stderr, "rendering band lines %d - %d w/%d \n", (int)rectPageLocation.yTop, (int)rectPageLocation.yBottom, iYBand);
+
+               if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
+               if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
+               if (fDebugOutput) fprintf(stderr, "Number of lines in band = %d\n", iYBand);
+               if (fDebugOutput) fprintf(stderr, "rectPageLocation - Top = %ld\n", rectPageLocation.yTop);
+               if (fDebugOutput) fprintf(stderr, "rectPageLocation - Bot = %ld\n", rectPageLocation.yBottom);
+               if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
+               if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
+
+               pDev->pfnRasterize ((void*)pasyncDev->pDev->pCallPtr,
+                                   pBitmapTop - ((iYBand-1) * uiBytesPerLine),
+                                   pbmi,
+                                   &sizelPage,
+                                   &rectPageLocation,
+                                   BITBLT_BITMAP);
+                                                       // memset the memory to white
+               memset (pBitmapMem, 0xFF, uiBytesPerLine * ulBandLength);
+            }
 
             // implemented based on the number of lines sent to the
             // printer and not based on the bandsize
 
-//            rectPageLocation.yBottom = pbmi->cy + iCurBot; @@10172000
+////////////rectPageLocation.yBottom = pbmi->cy + iCurBot; @@10172000
 
             rectPageLocation.yTop -= iYBand;   // @@10172000
-//            iCurBot =  rectPageLocation.yBottom;  @@10172000
-//            iCurTop =  rectPageLocation.yTop;     @@10172000
+////////////iCurBot =  rectPageLocation.yBottom;  @@10172000
+////////////iCurTop =  rectPageLocation.yTop;     @@10172000
 
             iYBand = 0;
          }
-      }        //@@04062001
-      if(!pDev->iGSMono)                                      //@@04252001
-          pDev->pfnMonoDither(&DiffInfo, &ImageInfo, &pBuffer, (unsigned long) GDM_DITHER_END);
+      } //@@04062001
+
+      if (!pDev->iGSMono)                                      //@@04252001
+         pDev->pfnMonoDither (&DiffInfo,
+                              &ImageInfo,
+                              &pBuffer,
+                              (unsigned long)GDM_DITHER_END);
+
       pBuffer = NULL;
    } //END BLOCK
 
-    //@@04162001
-//   pDev->pfnEndJob (pasyncDev->pDev->pDevice, pasyncDev->pDev->pOutputObject);
-
 done:
 
-    gs_free((char *) pBitmapMem, uiBytesPerLine * ulBandLength, 1, "Bitmap Memory");
-    fprintf(stderr, "Page Completed\n");
+   gs_free ((char *) pBitmapMem, uiBytesPerLine * ulBandLength, 1, "Bitmap Memory");
+   fprintf (stderr, "Page Completed\n");
 
-    gs_free((char *)pGSData, uiBytesPerLine, 1, "bmp file buffer");
-    gs_free((char *)pbmi, uiBytesPerLine, 1, "Bpmi Memory");
+   gs_free ((char *)pGSData, uiBytesPerLine, 1, "bmp file buffer");
+   gs_free ((char *)pbmi, uiBytesPerLine, 1, "Bpmi Memory");
 
-    /******************************************************************/
-    /* Note:                                         @@08162000       */
-    /*  GS has at least two threads for doing output on async devices.*/
-    /*  There is a writer and a render thread running at one time and */
-    /*  each have their own PageCount values.  The PageCount on the   */
-    /*  writer thread gets updated but the render thread (us) does    */
-    /*  not receive the update.  It looks like there needs to be a    */
-    /*  way to update the thread's device structure that is doing the */
-    /*  output with the new value when PageCount is changed.          */
-    /*  If the thread doing the rasterizing queries the PageCount     */
-    /*  value (calling put_params from inside of gxclrast.c) it will  */
-    /*  stop rendering the page -- BAD....                            */
-    /*  There needs to be a way to synchronize the two threads so that*/
-    /*  when the writer's thread actually updates the PageCount value */
-    /*  in both threads device structures get updated so we don't     */
-    /*  stop rasterizing the page.                                    */
-    /*                                                                */
-    /*    |  |  |  |                                                  */
-    /*   V  V  V  V                                                   */
-    /******************************************************************/
-
-    pgx_prt_dev->PageCount = pDev->iPage -1;
-
-    if (pasyncDev->copies_printed > 0)
-    {
-        pasyncDev->copies_printed = num_copies;
-    }
-    pasyncDev->buffered_page_exists = 0;
-    return code ;
+   /******************************************************************/
+   /* Note:                                         @@08162000       */
+   /*  GS has at least two threads for doing output on async devices.*/
+   /*  There is a writer and a render thread running at one time and */
+   /*  each have their own PageCount values.  The PageCount on the   */
+   /*  writer thread gets updated but the render thread (us) does    */
+   /*  not receive the update.  It looks like there needs to be a    */
+   /*  way to update the thread's device structure that is doing the */
+   /*  output with the new value when PageCount is changed.          */
+   /*  If the thread doing the rasterizing queries the PageCount     */
+   /*  value (calling put_params from inside of gxclrast.c) it will  */
+   /*  stop rendering the page -- BAD....                            */
+   /*  There needs to be a way to synchronize the two threads so that*/
+   /*  when the writer's thread actually updates the PageCount value */
+   /*  in both threads device structures get updated so we don't     */
+   /*  stop rasterizing the page.                                    */
+   /*                                                                */
+   /*    |  |  |  |                                                  */
+   /*   V  V  V  V                                                   */
+   /******************************************************************/
+   pgx_prt_dev->PageCount = pDev->iPage - 1;
+
+   if (pasyncDev->copies_printed > 0)
+   {
+      pasyncDev->copies_printed = num_copies;
+   }
+
+   pasyncDev->buffered_page_exists = 0;
+
+   return code;
 }
 
 /* -------------- Renderer instance procedures ----------*/
 
 /* Thread to do rendering, started by StartRenderThread */
 private void
-RenderThread(void *params)
+RenderThread (void *params)
 {
 #ifdef OMNI_ASYNC
-    gdev_prn_async_render_thread((gdev_prn_start_render_params *)params);
+   gdev_prn_async_render_thread ((gdev_prn_start_render_params *)params);
 #endif
 }
 
@@ -1683,136 +1690,153 @@
 /* ------------------------------------------------------*/
 
 private int /* rets 0 ok, -ve error if couldn't start thread */
-StartRenderThread(gdev_prn_start_render_params *params)
+StartRenderThread (gdev_prn_start_render_params *params)
 {
-    return gp_create_thread(RenderThread, params);
+   return gp_create_thread(RenderThread, params);
 }
 
 /* ------------------------------------------------------*/
 /* ------------------------------------------------------*/
 
 private int
-OpenRenderDevice(gx_device_printer *ppdev)
+OpenRenderDevice (gx_device_printer *ppdev)
 {
-    gx_device_omni * const pasyncDev = (gx_device_omni *)ppdev;
+   gx_device_omni * const pasyncDev = (gx_device_omni *)ppdev;
 
-    /* Do anything that needs to be done at open time here... */
-    pasyncDev->copies_printed = 0;
+   /* Do anything that needs to be done at open time here... */
+   pasyncDev->copies_printed = 0;
 
-    /* Cascade down to the default handler */
+   /* Cascade down to the default handler */
 #ifdef OMNI_ASYNC
-    return gdev_prn_async_render_open(ppdev);
+   return gdev_prn_async_render_open(ppdev);
 #else
-    return gs_note_error(gs_error_undefined);
+   return gs_note_error(gs_error_undefined);
 #endif
-
 }
+
 /* ------------------------------------------------------*/
 /* ------------------------------------------------------*/
 
 /* Buffer a (partial) rasterized page & optionally print result multiple times. */
 private int
-BufferPage(gx_device_printer *pgx_prt_dev, FILE *file, int num_copies)
+BufferPage (gx_device_printer *pgx_prt_dev, FILE *file, int num_copies)
 {
 #ifndef OMNI_ASYNC
-    /* locate_overlay_buffer is gone, so for now async printing is disabled */
-    return gs_note_error(gs_error_undefined);
+
+   /* locate_overlay_buffer is gone, so for now async printing is disabled */
+   return gs_note_error (gs_error_undefined);
+
 #else
-    gx_device_omni * const pasyncDev = (gx_device_omni *)pgx_prt_dev;
-    gx_device * const pgx_dev = (gx_device *)pgx_prt_dev;
-    int code = 0;
-
-    /* BMP format is single page, so discard all but 1st page */
-    if (pasyncDev->copies_printed > 0)
-        return 0;
-
-    /* If there's no data in buffer, no need to do any overlays */
-    if (!pasyncDev->buffered_page_exists) {
-       code = PrintPage(pgx_prt_dev, file, num_copies);
-       goto done;
-    }
-
-    /*
-     * Overlay file's bits on top of existing file There are two choices for
-     * doing this: get_overlay_bits vs.  the combination of
-     * locate_overlay_buffer and get_bits. If you already have a buffer in a
-     * format compatible with GS's format, use get_overlay_bits. If you'd
-     * rather use the buffer already in the device, use
-     * locate_overlay_buffer, copy the bits into the returned buffer, then
-     * get_bits.
-     *
-     * Either way, try to do entire bands at a shot for much greater
-     * efficiency.
-     */
-
-    /* Seek to beginning of data portion of file */
-    if (fseek(file, pasyncDev->file_offset_to_data, SEEK_SET))
-    {
-       code = gs_note_error(gs_error_ioerror);
-       goto done;
-    }
-
-
-    {
-       byte *raster_data;
-       int raster = gx_device_raster(pgx_dev, 1);
-       ulong bmp_raster = raster + (-raster & 3); /* BMP scan lines are padded to 32 bits. */
-       int max_band_height =
-           (*pgx_prt_dev->printer_procs.locate_overlay_buffer)(pgx_prt_dev, 0, &raster_data);
-       int band;
-       int file_raster_good = min(raster, bmp_raster);
-       long file_raster_slop = bmp_raster - file_raster_good;
-
-       /*
-        * iterate thru bands from top to bottom.
-        * Do this an entire band at a time for efficiency.
-        */
-       for (band = (pgx_prt_dev->height - 1) / max_band_height; band >= 0; --band)
-       {
-           int band_base_line = max_band_height * band;
-           int band_height = (*pgx_prt_dev->printer_procs.locate_overlay_buffer)
-           (pgx_prt_dev, band_base_line, &raster_data);
-           int line;
-
-           /* Fill in overlay buffer with a band from the BMP file. */
-           /* Need to do this backward since BMP is top to bottom */
-           for (line = band_height - 1; line >= 0; --line)
-               if (fread(raster_data + line * bmp_raster,
-                        file_raster_good, 1, file) < 1 ||
-                        fseek(file, file_raster_slop, SEEK_CUR))
-               {
-                  code = gs_note_error(gs_error_ioerror);
-                  goto done;
-               }
+   gx_device_omni * const pasyncDev = (gx_device_omni *)pgx_prt_dev;
+   gx_device * const      pgx_dev   = (gx_device *)pgx_prt_dev;
+   int                    code      = 0;
 
+   /* BMP format is single page, so discard all but 1st page */
+   if (pasyncDev->copies_printed > 0)
+      return 0;
 
-           /* Rewind & write out buffer with contents of get_bits */
-           if (fseek(file,-(file_raster_good + file_raster_slop) * band_height, SEEK_CUR))
-           {
-              code = gs_note_error(gs_error_ioerror);
-              goto done;
-           }
-
-           for (line = band_height - 1; line >= 0; --line)
-           {
-              if ((code = dev_proc(pgx_dev, get_bits)
-                 (pgx_dev, line + band_base_line, 0, &raster_data)) < 0 )
-                     goto done;
-              if (fwrite(raster_data, file_raster_good, 1, file) < 1 ||
-                 fseek(file, file_raster_slop, SEEK_CUR))
-              {
-                 code = gs_note_error(gs_error_ioerror);
-                 goto done;
-              }
-           }
-       }
-    }
+   /* If there's no data in buffer, no need to do any overlays */
+   if (!pasyncDev->buffered_page_exists)
+   {
+      code = PrintPage(pgx_prt_dev, file, num_copies);
+
+      goto done;
+   }
+
+   /*
+    * Overlay file's bits on top of existing file There are two choices for
+    * doing this: get_overlay_bits vs.  the combination of
+    * locate_overlay_buffer and get_bits. If you already have a buffer in a
+    * format compatible with GS's format, use get_overlay_bits. If you'd
+    * rather use the buffer already in the device, use
+    * locate_overlay_buffer, copy the bits into the returned buffer, then
+    * get_bits.
+    *
+    * Either way, try to do entire bands at a shot for much greater
+    * efficiency.
+    */
+
+   /* Seek to beginning of data portion of file */
+   if (fseek (file, pasyncDev->file_offset_to_data, SEEK_SET))
+   {
+      code = gs_note_error (gs_error_ioerror);
+
+      goto done;
+   }
+
+   {
+      byte  *raster_data;
+      int    raster           = gx_device_raster (pgx_dev, 1);
+      ulong  bmp_raster       = raster + (-raster & 3); /* BMP scan lines are padded to 32 bits. */
+      int    max_band_height  = (*pgx_prt_dev->printer_procs.locate_overlay_buffer) (pgx_prt_dev, 0, &raster_data);
+      int    band;
+      int    file_raster_good = min (raster, bmp_raster);
+      long   file_raster_slop = bmp_raster - file_raster_good;
+
+      /*
+       * iterate thru bands from top to bottom.
+       * Do this an entire band at a time for efficiency.
+       */
+      for (band = (pgx_prt_dev->height - 1) / max_band_height; band >= 0; --band)
+      {
+         int band_base_line = max_band_height * band;
+         int band_height    = (*pgx_prt_dev->printer_procs.locate_overlay_buffer) (pgx_prt_dev, band_base_line, &raster_data);
+         int line;
+
+         /* Fill in overlay buffer with a band from the BMP file. */
+         /* Need to do this backward since BMP is top to bottom */
+         for (line = band_height - 1; line >= 0; --line)
+         {
+            if (  fread (raster_data + line * bmp_raster,
+                         file_raster_good,
+                         1,
+                         file) < 1
+               || fseek (file, file_raster_slop, SEEK_CUR)
+               )
+            {
+               code = gs_note_error (gs_error_ioerror);
+
+               goto done;
+            }
+         }
+
+         /* Rewind & write out buffer with contents of get_bits */
+         if (fseek (file,
+                    -(file_raster_good + file_raster_slop) * band_height,
+                    SEEK_CUR))
+         {
+            code = gs_note_error(gs_error_ioerror);
+
+            goto done;
+         }
+
+         for (line = band_height - 1; line >= 0; --line)
+         {
+            if ((code = dev_proc (pgx_dev, get_bits) (pgx_dev, line + band_base_line, 0, &raster_data)) < 0 )
+               goto done;
+
+            if (  fwrite (raster_data, file_raster_good, 1, file) < 1
+               || fseek(file, file_raster_slop, SEEK_CUR)
+               )
+            {
+               code = gs_note_error(gs_error_ioerror);
+
+               goto done;
+            }
+         }
+      }
+   }
+
+done:
+   if (  code >= 0
+      && pasyncDev->copies_printed > 0
+      )
+      pasyncDev->copies_printed = num_copies;
+
+   pasyncDev->buffered_page_exists = (code >= 0);
+
+   return code;
 
- done:
-    if (code >= 0 && pasyncDev->copies_printed > 0)
-       pasyncDev->copies_printed = num_copies;
-    pasyncDev->buffered_page_exists = (code >= 0);
-    return code;
 #endif
 }
 
@@ -1822,132 +1846,126 @@
 
 /* Compute space parameters */
 private void
-GetSpaceParams(const gx_device_printer *pgx_prt_dev,
- gdev_prn_space_params *space_params)
+GetSpaceParams (const gx_device_printer *pgx_prt_dev,
+                gdev_prn_space_params   *space_params)
 {
-    /* Plug params into device before opening it
-     *
-     * You ask "How did you come up with these #'s?" You asked, so...
-     *
-     * To answer clearly, let me begin by recapitulating how command list
-     * (clist) device memory allocation works in the non-overlapped case:
-     * When the device is opened, a buffer is allocated. How big? For
-     * starters, it must be >= PRN_MIN_BUFFER_SPACE, and as we'll see, must
-     * be sufficient to satisfy the rest of the band params. If you don't
-     * specify a size for it in space_params.band.BandBufferSpace, the open
-     * routine will use a heuristic where it tries to use PRN_BUFFER_SPACE,
-     * then works its way down by factors of 2 if that much memory isn't
-     * available.
-     *
-     * The device proceeds to divide the buffer into several parts: one of
-     * them is used for the same thing during writing & rasterizing; the
-     * other parts are redivided and used differently writing and
-     * rasterizing. The limiting factor dictating memory requirements is the
-     * rasterizer's render buffer.  This buffer needs to be able to contain
-     * a bitmap that covers an entire band. Memory consumption is whatever
-     * is needed to hold N rows of data aligned on word boundaries, +
-     * sizeof(pointer) for each of N rows. Whatever is left over in the
-     * rasterized is allocated to a tile cache. You want to make sure that
-     * cache is at least 50KB.
-     *
-     * For example, take a 600 dpi b/w device at 8.5 x 11 inches.  For the
-     * whole device, that's 6600 rows @ 638 bytes = ~4.2 MB total.  If the
-     * device is divided into 100 bands, each band's rasterizer buffer is
-     * 62K. Add on a 50K tile cache, and you get a 112KB (+ add a little
-     * slop) total device buffer size.
-     *
-     * Now that we've covered the rasterizer, let's switch back to the
-     * writer. The writer must have a tile cache *exactly* the same size as
-     * the reader. This means that the space to divide up for the writer is
-     * equal is size to the rasterizer's band buffer.  This space is divided
-     * into 2 sections: per-band bookeeping info and a command buffer. The
-     * bookeeping info currently uses ~72 bytes for each band. The rest is
-     * the command buffer.
-     *
-     * To continue the same 112KB example, we have 62KB to slice up.
-     * We need 72 bytes * 100 bands = 7.2KB, leaving a 55K command buffer.
-     *
-     * A larger command buffer has some performance (see gxclmem.c comments)
-     * advantages in the general case, but is critical in one special case:
-     * high-level images. Whenever possible, images are transmitted across
-     * the band buffer in their original resolution and bits/pixel. The
-     * alternative fallback behavior can be very slow.  Here, the relevant
-     * restriction is that at least one entire source image row must fit
-     * into the command buffer. This means that, in our example, an RGB
-     * source image would have to be <= 18K pixels wide. If the image is
-     * sampled at the same resolution as the hardware (600 dpi), that means
-     * the row would be limited to a very reasonable 30 inches. However, if
-     * the source image is sampled at 2400 dpi, that limit is only 7.5
-     * inches. The situation gets worse as bands get smaller, but the
-     * implementor must decide on the tradeoff point.
-     *
-     * The moral of the story is that you should never make a band
-     * so small that its buffer limits the command buffer excessively.
-     * Again, Max image row bytes = band buffer size - # bands * 72.
-     *
-     * In the overlapped case, everything is exactly as above, except that
-     * two identical devices, each with an identical buffer, are allocated:
-     * one for the writer, and one for the rasterizer. Because it's critical
-     * to allocate identical buffers, I *strongly* recommend setting these
-     * params in the writer's open routine:
-     * space_params.band.BandBufferSpace, .BandWidth and .BandHeight.  If
-     * you don't force these values to a known value, the memory allocation
-     * heuristic may not come to the same result for both copies of the
-     * device, since the first allocation will diminish the amount of free
-     * memory.
-     *
-     * There is room for an important optimization here: allocate the
-     * writer's space with enough memory for a generous command buffer, but
-     * allocate the reader with only enough memory for a band rasterization
-     * buffer and the tile cache.  To do this, observe that the space_params
-     * struct has two sizes: BufferSpace vs. BandBufferSpace.  To start,
-     * BandBufferSpace is always <= BufferSpace. On the reader side,
-     * BandBufferSpace is divided between the tile cache and the rendering
-     * buffer -- that's all the memory that's needed to rasterize. On the
-     * writer's side, BandBufferSpace is divided the same way: the tile
-     * cache (which must be identical to the reader's) is carved out, and
-     * the space that would have been used for a rasterizing buffer is used
-     * as a command buffer. However, you can further increase the cmd buf
-     * further by setting BufferSize (not BandBufferSize) to a higher number
-     * than BandBufferSize. In that case, the command buffer is increased by
-     * the difference (BufferSize - BandBufferSize). There is logic in the
-     * memory allocation for printers that will automatically use BufferSize
-     * for writers (or non-async printers), and BandBufferSize for readers.
-     *
-     * Note: per the comments in gxclmem.c, the banding logic will perform
-     * better with 1MB or better for the command list.
-     */
-
-    /* This will give us a very "ungenerous" buffer. */
-    /* Here, my arbitrary rule for min image row is: twice the dest width */
-    /* in full RGB. */
-    int render_space;
-    int writer_space;
-    const int tile_cache_space = 50 * 1024;
-    const int min_image_rows = 2;
-    int min_row_space =
-    min_image_rows * (  3 * ( pgx_prt_dev->width + sizeof(int) - 1 )  );
-    int min_band_count = max(1, pgx_prt_dev->height / 100);	/* make bands >= 1% of total */
-
-    space_params->band.BandWidth = pgx_prt_dev->width;
-    space_params->band.BandHeight
-    = (pgx_prt_dev->height + min_band_count - 1) / min_band_count;
-
-    render_space = gdev_mem_data_size( (const gx_device_memory *)pgx_prt_dev,
-                                          space_params->band.BandWidth,
-                                          space_params->band.BandHeight );
-    /* need to include minimal writer requirements to satisfy rasterizer init */
-    writer_space = 	/* add 5K slop for good measure */
-    5000 + (72 + 8) * ( (pgx_prt_dev->height / space_params->band.BandHeight) + 1 );
-    space_params->band.BandBufferSpace =
-    max(render_space, writer_space) + tile_cache_space;
-    space_params->BufferSpace =
-    max(render_space, writer_space + min_row_space) + tile_cache_space;
-}
-
-
+   /* Plug params into device before opening it
+    *
+    * You ask "How did you come up with these #'s?" You asked, so...
+    *
+    * To answer clearly, let me begin by recapitulating how command list
+    * (clist) device memory allocation works in the non-overlapped case:
+    * When the device is opened, a buffer is allocated. How big? For
+    * starters, it must be >= PRN_MIN_BUFFER_SPACE, and as we'll see, must
+    * be sufficient to satisfy the rest of the band params. If you don't
+    * specify a size for it in space_params.band.BandBufferSpace, the open
+    * routine will use a heuristic where it tries to use PRN_BUFFER_SPACE,
+    * then works its way down by factors of 2 if that much memory isn't
+    * available.
+    *
+    * The device proceeds to divide the buffer into several parts: one of
+    * them is used for the same thing during writing & rasterizing; the
+    * other parts are redivided and used differently writing and
+    * rasterizing. The limiting factor dictating memory requirements is the
+    * rasterizer's render buffer.  This buffer needs to be able to contain
+    * a bitmap that covers an entire band. Memory consumption is whatever
+    * is needed to hold N rows of data aligned on word boundaries, +
+    * sizeof(pointer) for each of N rows. Whatever is left over in the
+    * rasterized is allocated to a tile cache. You want to make sure that
+    * cache is at least 50KB.
+    *
+    * For example, take a 600 dpi b/w device at 8.5 x 11 inches.  For the
+    * whole device, that's 6600 rows @ 638 bytes = ~4.2 MB total.  If the
+    * device is divided into 100 bands, each band's rasterizer buffer is
+    * 62K. Add on a 50K tile cache, and you get a 112KB (+ add a little
+    * slop) total device buffer size.
+    *
+    * Now that we've covered the rasterizer, let's switch back to the
+    * writer. The writer must have a tile cache *exactly* the same size as
+    * the reader. This means that the space to divide up for the writer is
+    * equal is size to the rasterizer's band buffer.  This space is divided
+    * into 2 sections: per-band bookeeping info and a command buffer. The
+    * bookeeping info currently uses ~72 bytes for each band. The rest is
+    * the command buffer.
+    *
+    * To continue the same 112KB example, we have 62KB to slice up.
+    * We need 72 bytes * 100 bands = 7.2KB, leaving a 55K command buffer.
+    *
+    * A larger command buffer has some performance (see gxclmem.c comments)
+    * advantages in the general case, but is critical in one special case:
+    * high-level images. Whenever possible, images are transmitted across
+    * the band buffer in their original resolution and bits/pixel. The
+    * alternative fallback behavior can be very slow.  Here, the relevant
+    * restriction is that at least one entire source image row must fit
+    * into the command buffer. This means that, in our example, an RGB
+    * source image would have to be <= 18K pixels wide. If the image is
+    * sampled at the same resolution as the hardware (600 dpi), that means
+    * the row would be limited to a very reasonable 30 inches. However, if
+    * the source image is sampled at 2400 dpi, that limit is only 7.5
+    * inches. The situation gets worse as bands get smaller, but the
+    * implementor must decide on the tradeoff point.
+    *
+    * The moral of the story is that you should never make a band
+    * so small that its buffer limits the command buffer excessively.
+    * Again, Max image row bytes = band buffer size - # bands * 72.
+    *
+    * In the overlapped case, everything is exactly as above, except that
+    * two identical devices, each with an identical buffer, are allocated:
+    * one for the writer, and one for the rasterizer. Because it's critical
+    * to allocate identical buffers, I *strongly* recommend setting these
+    * params in the writer's open routine:
+    * space_params.band.BandBufferSpace, .BandWidth and .BandHeight.  If
+    * you don't force these values to a known value, the memory allocation
+    * heuristic may not come to the same result for both copies of the
+    * device, since the first allocation will diminish the amount of free
+    * memory.
+    *
+    * There is room for an important optimization here: allocate the
+    * writer's space with enough memory for a generous command buffer, but
+    * allocate the reader with only enough memory for a band rasterization
+    * buffer and the tile cache.  To do this, observe that the space_params
+    * struct has two sizes: BufferSpace vs. BandBufferSpace.  To start,
+    * BandBufferSpace is always <= BufferSpace. On the reader side,
+    * BandBufferSpace is divided between the tile cache and the rendering
+    * buffer -- that's all the memory that's needed to rasterize. On the
+    * writer's side, BandBufferSpace is divided the same way: the tile
+    * cache (which must be identical to the reader's) is carved out, and
+    * the space that would have been used for a rasterizing buffer is used
+    * as a command buffer. However, you can further increase the cmd buf
+    * further by setting BufferSize (not BandBufferSize) to a higher number
+    * than BandBufferSize. In that case, the command buffer is increased by
+    * the difference (BufferSize - BandBufferSize). There is logic in the
+    * memory allocation for printers that will automatically use BufferSize
+    * for writers (or non-async printers), and BandBufferSize for readers.
+    *
+    * Note: per the comments in gxclmem.c, the banding logic will perform
+    * better with 1MB or better for the command list.
+    */
 
+   /* This will give us a very "ungenerous" buffer. */
+   /* Here, my arbitrary rule for min image row is: twice the dest width */
+   /* in full RGB. */
+   int       render_space;
+   int       writer_space;
+   const int tile_cache_space = 50 * 1024;
+   const int min_image_rows   = 2;
+   int       min_row_space    = min_image_rows * (3 * (pgx_prt_dev->width + sizeof (int) - 1));
+   int       min_band_count   = max (1, pgx_prt_dev->height / 100); /* make bands >= 1% of total */
+
+   space_params->band.BandWidth  = pgx_prt_dev->width;
+   space_params->band.BandHeight = (pgx_prt_dev->height + min_band_count - 1) / min_band_count;
+
+   render_space = gdev_mem_data_size ((const gx_device_memory *)pgx_prt_dev,
+                                      space_params->band.BandWidth,
+                                      space_params->band.BandHeight);
+
+   /* need to include minimal writer requirements to satisfy rasterizer init */
+   writer_space = 5000 /* add 5K slop for good measure */
+                + (72 + 8) * ((pgx_prt_dev->height / space_params->band.BandHeight) + 1);
 
+   space_params->band.BandBufferSpace = max (render_space, writer_space) + tile_cache_space;
+   space_params->BufferSpace = max (render_space, writer_space + min_row_space) + tile_cache_space;
+}
 
 /*-----------------------------------------------------------------------------*/
 /*                                                                             */
@@ -1957,54 +1975,53 @@
 /*  bitmap, and the specifics of the hardware                                  */
 /*                                                                             */
 /*-----------------------------------------------------------------------------*/
+ULONG
+FindBandSize (ULONG ulYHeight,
+              ULONG ulXWidth,
+              ULONG ulBitsPerPel,
+              ULONG ulNumPlanes,
+              ULONG ulModulus,
+              ULONG ulMemoryLimit)
+{
+   ULONG ulSizeScanLine;
+   ULONG ulMemoryNeeded;
+   ULONG ulNumLinesFit;
 
+   if (0 == ulModulus)
+   {
+      ulModulus = 1;
+   }
 
+   // figure out how much memory is needed fore each line
+   ulSizeScanLine = ((ulBitsPerPel*ulXWidth+31)/32)*ulNumPlanes*4;
 
-ULONG FindBandSize(ULONG ulYHeight, ULONG ulXWidth, ULONG ulBitsPerPel, ULONG ulNumPlanes,
-                            ULONG ulModulus, ULONG ulMemoryLimit)
-{
-    ULONG ulSizeScanLine;
-    ULONG ulMemoryNeeded;
-    ULONG ulNumLinesFit;
-
-    if (0 == ulModulus)
-    {
-       ulModulus = 1;
-    }
-    // figure out how much memory is needed fore each line
-    ulSizeScanLine = ((ulBitsPerPel*ulXWidth+31)/32)*ulNumPlanes*4;
-
-    // Figure out how much memory is needed for the page
-    ulMemoryNeeded = ulYHeight * ulSizeScanLine;
-
-    // How many lines can fit in the size given?
-    ulNumLinesFit = ulMemoryLimit / ulSizeScanLine;
-
-    if (0 == ulNumLinesFit)
-       // Minimum of 1 scan line
-       ulNumLinesFit = 1;
-
-    if (ulNumLinesFit <= ulModulus)
-       // Not enough lines... Promote it to a modulus.
-       ulNumLinesFit = ulModulus;
-    else
-       // Bump down the number of lines so that it is a modulus.
-       ulNumLinesFit -= ulNumLinesFit % ulModulus;
-
-    if ((ulYHeight % ulNumLinesFit) * 100 / ulYHeight <= 15)
-    {
-       USHORT  usBumpUp;
-
-       usBumpUp  = ulYHeight % ulNumLinesFit;
-       usBumpUp += ulModulus - 1;
-       usBumpUp /= ulModulus;
-       usBumpUp *= ulModulus;
-       ulNumLinesFit += usBumpUp;
-    }
+   // Figure out how much memory is needed for the page
+   ulMemoryNeeded = ulYHeight * ulSizeScanLine;
 
-    return ulNumLinesFit ;  // return the number of lines we want for the band
+   // How many lines can fit in the size given?
+   ulNumLinesFit = ulMemoryLimit / ulSizeScanLine;
 
-}
+   if (0 == ulNumLinesFit)
+      // Minimum of 1 scan line
+      ulNumLinesFit = 1;
 
+   if (ulNumLinesFit <= ulModulus)
+      // Not enough lines... Promote it to a modulus.
+      ulNumLinesFit = ulModulus;
+   else
+      // Bump down the number of lines so that it is a modulus.
+      ulNumLinesFit -= ulNumLinesFit % ulModulus;
 
+   if ((ulYHeight % ulNumLinesFit) * 100 / ulYHeight <= 15)
+   {
+      USHORT  usBumpUp;
 
+      usBumpUp  = ulYHeight % ulNumLinesFit;
+      usBumpUp += ulModulus - 1;
+      usBumpUp /= ulModulus;
+      usBumpUp *= ulModulus;
+      ulNumLinesFit += usBumpUp;
+   }
+
+   return ulNumLinesFit ;  // return the number of lines we want for the band
+}
