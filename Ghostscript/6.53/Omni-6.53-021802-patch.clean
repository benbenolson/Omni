diff -C5 --unidirectional-new-file gs-6.53_new/ghostscript-6.53/src/contrib.mak gs-6.53_newb/ghostscript-6.53/src/contrib.mak
*** gs-6.53_new/ghostscript-6.53/src/contrib.mak	Wed Jan 23 18:14:41 2002
--- gs-6.53_newb/ghostscript-6.53/src/contrib.mak	Wed Feb 13 13:09:22 2002
***************
*** 482,492 ****
  
  $(DD)omni.dev : $(GLOBJ)gomni.$(OBJ) $(DD)page.dev
  	$(SETPDEV) $(DD)omni $(GLOBJ)gomni.$(OBJ)
  
  $(GLOBJ)gomni.$(OBJ) : $(GLSRC)gomni.c $(epclr_h1) $(PDEVH)
! 	$(GLCC) $(GLO_)gomni.$(OBJ) $(C_) $(GLSRC)gomni.c
  
  ### --------------- Ugly/Update -> Unified Printer Driver ---------------- ###
  ### For questions about this driver, please contact:                       ###
  ###        Gunther Hess (gunther@elmos.de)                                 ###
  
--- 482,492 ----
  
  $(DD)omni.dev : $(GLOBJ)gomni.$(OBJ) $(DD)page.dev
  	$(SETPDEV) $(DD)omni $(GLOBJ)gomni.$(OBJ)
  
  $(GLOBJ)gomni.$(OBJ) : $(GLSRC)gomni.c $(epclr_h1) $(PDEVH)
! 	$(GLCC) $(GLO_)gomni.$(OBJ) `glib-config --cflags gmodule` $(C_) $(GLSRC)gomni.c
  
  ### --------------- Ugly/Update -> Unified Printer Driver ---------------- ###
  ### For questions about this driver, please contact:                       ###
  ###        Gunther Hess (gunther@elmos.de)                                 ###
  
diff -C5 --unidirectional-new-file gs-6.53_new/ghostscript-6.53/src/defs.h gs-6.53_newb/ghostscript-6.53/src/defs.h
*** gs-6.53_new/ghostscript-6.53/src/defs.h	Thu May 31 03:28:49 2001
--- gs-6.53_newb/ghostscript-6.53/src/defs.h	Wed Feb 13 13:30:23 2002
***************
*** 111,155 ****
  #define HIUCHAR(w)      ((UCHAR)(((USHORT)(w) >> 8) & 0xff))
  #define LOUSHORT(l)     ((USHORT)((ULONG)l))
  #define HIUSHORT(l)     ((USHORT)(((ULONG)(l) >> 16) & 0xffff))
  
  
!    #define CLR_FALSE                     (-5L)
!    #define CLR_TRUE                      (-4L)
  
!    #define CLR_ERROR                   (-255L)
!    #define CLR_DEFAULT                   (-3L)
!    #define CLR_WHITE                     (-2L)
!    #define CLR_BLACK                     (-1L)
!    #define CLR_BACKGROUND                  0L
!    #define CLR_BLUE                        1L
!    #define CLR_RED                         2L
!    #define CLR_PINK                        3L
!    #define CLR_GREEN                       4L
!    #define CLR_CYAN                        5L
!    #define CLR_YELLOW                      6L
!    #define CLR_NEUTRAL                     7L
! 
!    #define CLR_DARKGRAY                    8L
!    #define CLR_DARKBLUE                    9L
!    #define CLR_DARKRED                    10L
!    #define CLR_DARKPINK                   11L
!    #define CLR_DARKGREEN                  12L
!    #define CLR_DARKCYAN                   13L
!    #define CLR_BROWN                      14L
!    #define CLR_PALEGRAY                   15L
! 
!    /* rgb colors */
!    #define RGB_ERROR                   (-255L)
!    #define RGB_BLACK              0x00000000L
!    #define RGB_BLUE               0x000000FFL
!    #define RGB_GREEN              0x0000FF00L
!    #define RGB_CYAN               0x0000FFFFL
!    #define RGB_RED                0x00FF0000L
!    #define RGB_PINK               0x00FF00FFL
!    #define RGB_YELLOW             0x00FFFF00L
!    #define RGB_WHITE              0x00FFFFFFL
  
  
  
  #define BMAP_MEMORY          0x00000001
  
--- 111,155 ----
  #define HIUCHAR(w)      ((UCHAR)(((USHORT)(w) >> 8) & 0xff))
  #define LOUSHORT(l)     ((USHORT)((ULONG)l))
  #define HIUSHORT(l)     ((USHORT)(((ULONG)(l) >> 16) & 0xffff))
  
  
! #define CLR_FALSE                     (-5L)
! #define CLR_TRUE                      (-4L)
  
! #define CLR_ERROR                   (-255L)
! #define CLR_DEFAULT                   (-3L)
! #define CLR_WHITE                     (-2L)
! #define CLR_BLACK                     (-1L)
! #define CLR_BACKGROUND                  0L
! #define CLR_BLUE                        1L
! #define CLR_RED                         2L
! #define CLR_PINK                        3L
! #define CLR_GREEN                       4L
! #define CLR_CYAN                        5L
! #define CLR_YELLOW                      6L
! #define CLR_NEUTRAL                     7L
! 
! #define CLR_DARKGRAY                    8L
! #define CLR_DARKBLUE                    9L
! #define CLR_DARKRED                    10L
! #define CLR_DARKPINK                   11L
! #define CLR_DARKGREEN                  12L
! #define CLR_DARKCYAN                   13L
! #define CLR_BROWN                      14L
! #define CLR_PALEGRAY                   15L
! 
! /* rgb colors */
! #define RGB_ERROR                   (-255L)
! #define RGB_BLACK              0x00000000L
! #define RGB_BLUE               0x000000FFL
! #define RGB_GREEN              0x0000FF00L
! #define RGB_CYAN               0x0000FFFFL
! #define RGB_RED                0x00FF0000L
! #define RGB_PINK               0x00FF00FFL
! #define RGB_YELLOW             0x00FFFF00L
! #define RGB_WHITE              0x00FFFFFFL
  
  
  
  #define BMAP_MEMORY          0x00000001
  
diff -C5 --unidirectional-new-file gs-6.53_new/ghostscript-6.53/src/gomni.c gs-6.53_newb/ghostscript-6.53/src/gomni.c
*** gs-6.53_new/ghostscript-6.53/src/gomni.c	Tue Jun  5 17:35:34 2001
--- gs-6.53_newb/ghostscript-6.53/src/gomni.c	Mon Feb 18 18:14:52 2002
***************
*** 1,6 ****
! /*
   *   IBM Omni driver
   *   Copyright (c) International Business Machines Corp., 2000
   *
   *   This library is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU Lesser General Public License as published
--- 1,6 ----
! /*  
   *   IBM Omni driver
   *   Copyright (c) International Business Machines Corp., 2000
   *
   *   This library is free software; you can redistribute it and/or modify
   *   it under the terms of the GNU Lesser General Public License as published
***************
*** 76,87 ****
--- 76,98 ----
  /*                     interaction instead of writing the data          */
  /*                     directly to a file                               */
  /*                                                                      */
  /*    @@05052001A      Update mulitplier for .0001 mm vs. .001 mm       */
  /*                                                                      */
+ /*    1/28/2002        changed code to utilize a core omni structure    */
+ /*                     to allow for management of devices linked        */
+ /*                     to servers and allow device code re-entrancy     */
+ /*                                                                      */
+ /*    @@01302002       Changed code to utilize -sserver from the        */
+ /*                     command line instead of having to provide a      */
+ /*                     file name along with the server                  */
+ /*                                                                      */
  /************************************************************************/
  
+ // Include these first.  Ghostscript redefines printf
+ #include <glib.h>
+ #include <gmodule.h>
  
  #include "gdevprna.h"
  #include "gdevpccm.h"
  #include "gdevprn.h"
  #include "gsparam.h"
***************
*** 91,101 ****
  #include "gserrors.h"
  #include "gpsync.h"
  
  #include "defs.h"
  
! #include <dlfcn.h>
  
  const static int fDebugOutput = 0;
  
  #define DEVICES_DEFINED
  #define ORIENTATION_STRING "orientation=ORIENTATION_PORTRAIT"
--- 102,114 ----
  #include "gserrors.h"
  #include "gpsync.h"
  
  #include "defs.h"
  
! #define MAX_LENGTH 65
! 
! #define Signature "OMNI"
  
  const static int fDebugOutput = 0;
  
  #define DEVICES_DEFINED
  #define ORIENTATION_STRING "orientation=ORIENTATION_PORTRAIT"
***************
*** 133,163 ****
                                          PRINTMODE    *pPrtMode);
  typedef bool   (*PFNGETRESOLUTIONINFO) (void         *pDev,
                                          HWRESOLUTION *hwRes);
  typedef bool   (*PFNGETMARGININFO)     (void         *pDev,
                                          HWMARGINS    *hwMargins);
! typedef void   (*PFNBEGINJOB)          (void         *pDev,
!                                         FILE         *pFile);
  typedef void   (*PFNNEWFRAME)          (void         *pDev); //@@04162001
  
  typedef void   (*PFNENDJOB)            (void         *pDev,
                                          void         *pOutputObject);
! typedef void   (*PFNRASTERIZE)         (void         *pDevice,
                                          PBYTE         pbBits,
                                          PBITMAPINFO2  pbmi,
                                          PSIZEL        psizelPage,
                                          PRECTL        prectlPageLocation,
                                          BITBLT_TYPE   eType);
  typedef void * (*PFNCREATEDEVICE)      (char         *pszDeviceName,
                                          void         *pOutputObject,
!                                         void        **vhDevice,
                                          void         *pszDebugFile,
                                          char         *pszOptions,
                                          int           iUseClient,   //@@05092001
!                                         FILE          *file);       //@@05092001
! 
! typedef void   (*PFNDELETEDEVICE)      (void         *pDevice);
  
  typedef long   (*PFNMONODITHER)        (PDDI          pdi,           //@@04062001
                                          PIMAGEINFO    pimg_infos,
                                          PBYTE        *pBuffer,
                                          ULONG         ulFlgs);
--- 146,180 ----
                                          PRINTMODE    *pPrtMode);
  typedef bool   (*PFNGETRESOLUTIONINFO) (void         *pDev,
                                          HWRESOLUTION *hwRes);
  typedef bool   (*PFNGETMARGININFO)     (void         *pDev,
                                          HWMARGINS    *hwMargins);
! typedef bool   (*PFNGETVERSION)        (void         *pDev,
!                                         char         *OmniVersion);
! 
! typedef void   (* PFNBEGINJOB)         (void *pOmni,
!                                         FILE *pFile); 
! //                                        char  *pszDeviceName, 
! //                                        char  *pszJobProperties);
! 
  typedef void   (*PFNNEWFRAME)          (void         *pDev); //@@04162001
  
  typedef void   (*PFNENDJOB)            (void         *pDev,
                                          void         *pOutputObject);
! typedef void   (*PFNRASTERIZE)         (void         *pcoreOmni,
                                          PBYTE         pbBits,
                                          PBITMAPINFO2  pbmi,
                                          PSIZEL        psizelPage,
                                          PRECTL        prectlPageLocation,
                                          BITBLT_TYPE   eType);
  typedef void * (*PFNCREATEDEVICE)      (char         *pszDeviceName,
                                          void         *pOutputObject,
!                                         GModule     **hmodDevice,
                                          void         *pszDebugFile,
                                          char         *pszOptions,
                                          int           iUseClient,   //@@05092001
!                                         FILE         *file);        //@@05092001
  
  typedef long   (*PFNMONODITHER)        (PDDI          pdi,           //@@04062001
                                          PIMAGEINFO    pimg_infos,
                                          PBYTE        *pBuffer,
                                          ULONG         ulFlgs);
***************
*** 185,231 ****
      int         copies_printed;
      pDevStruct  pDev;            /**    Omni specific extensions */
  } gx_device_omni;
  typedef gx_device_omni omni_device;
  
  
- #define MAX_LENGTH 65
  
  struct _DevStruct { /* All omni specific data */
  
-    char                  cDeviceName[MAX_LENGTH];
-    char                  cDebugFile[MAX_LENGTH];   /* text value for dither */
     char                  cAsyncOpt[MAX_LENGTH];   /* text value for dither */
     char                  cMonoDither[MAX_LENGTH];
     char                  cServer[32];             //@@05092001
     char                  cServerFile[256];        //@@05092001
-    char                 *pszOtherOptions;
     void                 *pOutputObject;            // can be used for redirecting cerr in C++ section
!    void                 *pDevice;                  // pointer to the device
  
!    void                 *vhOmni;                   // handle to libomni.so
!    void                 *vhDevice;                 // handle to libDeviceXXX.so
     PFNGETPRINTMODEINFO   pfnGetPrintModeInfo;
     PFNGETRESOLUTIONINFO  pfnGetResolutionInfo;
     PFNGETMARGININFO      pfnGetMarginInfo;
     PFNBEGINJOB           pfnBeginJob;
     PFNNEWFRAME           pfnNewFrame;    //@@04162001
     PFNENDJOB             pfnEndJob;
     PFNRASTERIZE          pfnRasterize;
     PFNCREATEDEVICE       pfnCreateDevice;
-    PFNDELETEDEVICE       pfnDeleteDevice;
     PFNMONODITHER         pfnMonoDither;    //@@04162001
! 
     unsigned long         ulPelSizeCorrection;
  
     int                   iVertDots;
     int                   width;
     int                   height;
     int                   iSync;
     int                   iPageNumber;  //@@04162001
     int                   iGSMono;      //@@04252001
     int                   iUseServer;   //@@05092001
     FILE                 *ProxyFile;    //@@05092001
  
     byte                 *outbuf;     /* Output-Buffer */
  
     int                   iPage;
--- 202,259 ----
      int         copies_printed;
      pDevStruct  pDev;            /**    Omni specific extensions */
  } gx_device_omni;
  typedef gx_device_omni omni_device;
  
+ typedef struct omni_dev_struct {
+     char cSignature[4];
+     char cVersion[10];
+     void *pDevice;                    // pointer to a standard device
+     void *pPDCDevice;                 // pointer to a PDC device for utilizing IPC
+     bool  bPDCDevice;                 // boolean to tell if this is a PDC device or not
+     FILE *pfile;                      // pointer to the output handle from beginjob
+     char *pszJobOptions;              // pointer to the job options
+     char  cDebugFile[MAX_LENGTH];     // debug file name
+     char  cDeviceName[MAX_LENGTH];
+     char  cOmniVersion[10];
+ } core_omni;
+ typedef core_omni core_omni_device;
+ 
  
  
  struct _DevStruct { /* All omni specific data */
  
     char                  cAsyncOpt[MAX_LENGTH];   /* text value for dither */
     char                  cMonoDither[MAX_LENGTH];
     char                  cServer[32];             //@@05092001
     char                  cServerFile[256];        //@@05092001
     void                 *pOutputObject;            // can be used for redirecting cerr in C++ section
!    core_omni_device     *pcoreOmni;
!    void                 *pCallPtr;
  
!    GModule              *hmodOmni;                   // handle to libomni.so
!    GModule              *hmodDevice;                 // handle to libDeviceXXX.so
     PFNGETPRINTMODEINFO   pfnGetPrintModeInfo;
     PFNGETRESOLUTIONINFO  pfnGetResolutionInfo;
     PFNGETMARGININFO      pfnGetMarginInfo;
     PFNBEGINJOB           pfnBeginJob;
     PFNNEWFRAME           pfnNewFrame;    //@@04162001
     PFNENDJOB             pfnEndJob;
     PFNRASTERIZE          pfnRasterize;
     PFNCREATEDEVICE       pfnCreateDevice;
     PFNMONODITHER         pfnMonoDither;    //@@04162001
!    PFNGETVERSION         pfnGetVersion;
     unsigned long         ulPelSizeCorrection;
  
     int                   iVertDots;
     int                   width;
     int                   height;
     int                   iSync;
     int                   iPageNumber;  //@@04162001
     int                   iGSMono;      //@@04252001
     int                   iUseServer;   //@@05092001
+    int                   iUseDialog;
     FILE                 *ProxyFile;    //@@05092001
  
     byte                 *outbuf;     /* Output-Buffer */
  
     int                   iPage;
***************
*** 360,380 ****
      int max_width;
      int max_raster;
      int min_band_height;
      int max_src_image_row;
  
!     if (!pDev || !pDev->vhOmni)
      {
         /* SetupDevice is called before OpenDevice is called.  Therefore, the
         ** initial loading of the omni driver is done there.  If that has failed
         ** (the library handle is 0), then fail this call.
         */
  
         return e_Fatal;
      }
  
      pDev->iPageNumber = 0;  //@@04162001
  
  //    if(pDev->pszOtherOptions)
  //       *pDev->pszOtherOptions = '\0';
  
      /*
--- 388,410 ----
      int max_width;
      int max_raster;
      int min_band_height;
      int max_src_image_row;
  
!     if (!pDev || !pDev->hmodOmni)
      {
         /* SetupDevice is called before OpenDevice is called.  Therefore, the
         ** initial loading of the omni driver is done there.  If that has failed
         ** (the library handle is 0), then fail this call.
         */
  
         return e_Fatal;
      }
  
+     pDev->iUseServer = 0;                                            //@@05092001
      pDev->iPageNumber = 0;  //@@04162001
+     pDev->iUseDialog = 0;
  
  //    if(pDev->pszOtherOptions)
  //       *pDev->pszOtherOptions = '\0';
  
      /*
***************
*** 441,491 ****
  CloseDevice (gx_device * pdev)
  {
     gx_device_omni * const pwdev = (gx_device_omni *)pdev;
     pDevStruct              pDev  = pwdev->pDev;
  
!    if(!pDev || !pDev->pDevice)
     {
       return_error(gs_error_Fatal);  // handle no pDev
     }
     /***
      *     WE NEED TO TERMINATE HERE!!!!!!!!!
      *     @@04162001
      ***/
     if (pDev->pfnEndJob)
     {
!        pDev->pfnEndJob (pDev->pDevice, pDev->pOutputObject);
         pDev->pfnEndJob = 0;
     }
  
!    if (pDev->pDevice && pDev->pfnDeleteDevice)           //@@05092001
!    {                                                     
!       pDev->pfnDeleteDevice (pDev->pDevice);             
!       pDev->pDevice = 0;                                 
!    }                                                     
  
!    if (pDev->vhDevice)
     {
!       dlclose (pDev->vhDevice);
!       pDev->vhDevice = 0;
     }
  
!    if (pDev->vhOmni)
     {
!       dlclose (pDev->vhOmni);
!       pDev->vhOmni = 0;
     }
  
!    if (pDev->pszOtherOptions)
     {
!        gs_free(pDev->pszOtherOptions,strlen(pDev->pszOtherOptions)+1, 1, "Option String");
     }
  
!    if(pDev->ProxyFile)                                    //@@05092001
!    {                                                      //@@05092001
!        fclose(pDev->ProxyFile);                           //@@05092001
!    }                                                      //@@05092001
  
     return gdev_prn_close (pdev);
  
  }
  
--- 471,525 ----
  CloseDevice (gx_device * pdev)
  {
     gx_device_omni * const pwdev = (gx_device_omni *)pdev;
     pDevStruct              pDev  = pwdev->pDev;
  
!    if(!pDev || !pDev->pcoreOmni->pDevice)
     {
       return_error(gs_error_Fatal);  // handle no pDev
     }
     /***
      *     WE NEED TO TERMINATE HERE!!!!!!!!!
      *     @@04162001
      ***/
     if (pDev->pfnEndJob)
     {
!        pDev->pfnEndJob ((void*) pDev->pCallPtr, pDev->pOutputObject);
         pDev->pfnEndJob = 0;
     }
  
!    if (pDev->pcoreOmni->pszJobOptions)
!    {
!        gs_free(pDev->pcoreOmni->pszJobOptions,strlen(pDev->pcoreOmni->pszJobOptions)+1, 1, "Option String");
!    }
  
!    if (pDev->pcoreOmni)    
     {
!       gs_free(pDev->pcoreOmni , sizeof(core_omni_device), 1, "omni/device" );
!       pDev->pcoreOmni = 0;
     }
  
!    if (pDev->hmodDevice)
     {
!       g_module_close (pDev->hmodDevice);
!       pDev->hmodDevice = 0;
     }
  
!    if (pDev->hmodOmni)
     {
!       g_module_close (pDev->hmodOmni);
!       pDev->hmodOmni = 0;
     }
  
! 
!    // Removed following code so commandline server invocation is
!    // just -sserver  @@01302002
! 
! //   if(pDev->ProxyFile)                                    //@@05092001
! //   {                                                      //@@05092001
! //       fclose(pDev->ProxyFile);                           //@@05092001
! //   }                                                      //@@05092001
  
     return gdev_prn_close (pdev);
  
  }
  
***************
*** 523,539 ****
  
     iReturnCode = gdev_prn_get_params ( pgxdev, plist );
     if (pDev)
     {
         bPersist            = true;
!        pszDeviceName       = pDev->cDeviceName;
!        pszDebug            = pDev->cDebugFile;
!        pszOther            = pDev->pszOtherOptions;
         pszAsync            = pDev->cAsyncOpt;
         ulPelSizeCorrection = pDev->ulPelSizeCorrection;
         pszMonoDither       = pDev->cMonoDither;
!        pszServer           = pDev->cServerFile;              //@@05092001
  
         // Return if we already did our work here
         if(strlen(pszDeviceName) > 0)
         {
             return iReturnCode;
--- 557,576 ----
  
     iReturnCode = gdev_prn_get_params ( pgxdev, plist );
     if (pDev)
     {
         bPersist            = true;
!        pszDeviceName       = pDev->pcoreOmni->cDeviceName;
!        pszDebug            = pDev->pcoreOmni->cDebugFile;
!        pszOther            = pDev->pcoreOmni->pszJobOptions;
         pszAsync            = pDev->cAsyncOpt;
         ulPelSizeCorrection = pDev->ulPelSizeCorrection;
         pszMonoDither       = pDev->cMonoDither;
! 
!        // Removed following code so commandline server invocation is
!        // just -sserver  @@01302002
! //       pszServer           = pDev->cServerFile;              //@@05092001
  
         // Return if we already did our work here
         if(strlen(pszDeviceName) > 0)
         {
             return iReturnCode;
***************
*** 547,557 ****
     strdata.data = pszDebug;
     strdata.size = strlen(pszDebug);
     strdata.persistent = bPersist;
     iReturnCode = param_write_string(plist,"dbgout",&strdata);
  
!    if(pDev && pDev->pszOtherOptions)
     {
         strdata.size = strlen(pszOther);
         strdata.data = pszOther;
     }
     else
--- 584,594 ----
     strdata.data = pszDebug;
     strdata.size = strlen(pszDebug);
     strdata.persistent = bPersist;
     iReturnCode = param_write_string(plist,"dbgout",&strdata);
  
!    if(pDev && pDev->pcoreOmni->pszJobOptions)
     {
         strdata.size = strlen(pszOther);
         strdata.data = pszOther;
     }
     else
***************
*** 577,586 ****
--- 614,628 ----
     strdata.data = pszServer;                                      //@@05092001
     strdata.size = strlen(pszServer);                              //@@05092001
     strdata.persistent = bPersist;                                 //@@05092001
     iReturnCode = param_write_string(plist,"server",&strdata);     //@@05092001
  
+    strdata.data = pszServer;                                      //@@05092001
+    strdata.size = strlen(pszServer);                              //@@05092001
+    strdata.persistent = bPersist;                                 //@@05092001
+    iReturnCode = param_write_string(plist,"jobdialog",&strdata);     //@@05092001
+ 
     iReturnCode = param_write_long(plist,"PelSizeCorrection",&ulPelSizeCorrection);
  
     return iReturnCode;
  }
  
***************
*** 597,612 ****
  
  private int
  SetupDevice(gx_device *pgxdev, gs_param_list *plist)
  {
  
!    int                     iReturnCode;
     BOOL                    bRet;
     HWMARGINS               hwMargins;
     HWRESOLUTION            hwRes;
     gx_device_omni * const prgxdev  = (gx_device_omni *)pgxdev;
     pDevStruct              pDev     = prgxdev->pDev;
  
     PRINTMODE prtMode;  //definition of printed output Bpp ..
  
  // gs_param_string         =    data, size, persistant + byte data
     gs_param_string         fname    = { NULL, 0, false };
--- 639,664 ----
  
  private int
  SetupDevice(gx_device *pgxdev, gs_param_list *plist)
  {
  
!    int                     iReturnCode, i;
     BOOL                    bRet;
     HWMARGINS               hwMargins;
     HWRESOLUTION            hwRes;
     gx_device_omni * const prgxdev  = (gx_device_omni *)pgxdev;
     pDevStruct              pDev     = prgxdev->pDev;
+    char *pszDeviceLib = 0;
+    static char cOmnilib[] = "libomni.so";
+    static char cDialogName[] = "libomnijobdialog.so";
+ 
+    static char *apszLibraryPaths[] = {
+       "/usr/lib/Omni/",
+       "/opt/Omni/bin/",
+       "./",
+       ""                // give a chance for $LD_LIBRARY_PATH to work
+    };
  
     PRINTMODE prtMode;  //definition of printed output Bpp ..
  
  // gs_param_string         =    data, size, persistant + byte data
     gs_param_string         fname    = { NULL, 0, false };
***************
*** 631,719 ****
            return_error(gs_error_Fatal);
         }
         else
         {
            memset (pDev, 0, sizeof (Omni_Dev));
           // prgxdev->pDev->pszOtherOptions = '\0';
         }
     }
  
!    if (!pDev->vhOmni)
     {
        pDev->ulPelSizeCorrection = 100;
  
!       pDev->vhOmni = dlopen ("libomni.so", RTLD_NOW | RTLD_GLOBAL);
! 
!       if (!pDev->vhOmni)
        {
!          // Failure!
!          fprintf (stderr, "\n<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n\n");
!          fprintf (stderr, "Error: Could not load libomni.so!\n\n");
  
!          // @TBD - why doesnt return_error(gs_error_Fatal) work?
!          //        If it is in, then we get the following:
!          //
!          // Unrecoverable error: rangecheck in .putdeviceprops
!          //
!          // Unexpected interpreter error -15.
!          // Error object: (1488)op_array(586)0x81bc858:.putdeviceprops
!          // Execution stack at 0x81b0940:
!          // 0x81c6c74: 0x0f oper --F---e-- 0x0000 0x08084fcc = %interp_exit
!          // 0x81c6c7c: 0x03 file --G-rxe-- 0x0001 0x081bd010
!          // 0x81c6c84: 0x0e null --F---e-- 0x0000 0x08086b94
!          // 0x81c6c8c: 0x0b int  --F------ 0x01ac 0x00000008 = 8
!          // 0x81c6c94: 0x0b int  --F------ 0x0007 0x00000004 = 4
!          // 0x81c6c9c: 0x0f oper --F---e-- 0x0000 0x08086b80 = %oparray_pop
!          // 0x81c6ca4: 0x05 mpry --G-rxe-- 0x0002 0x0821032c
!          // 0x81c6cac: 0x0e null --F---e-- 0x0000 0x08086b94
!          // 0x81c6cb4: 0x0b int  --F------ 0x0001 0x00000008 = 8
!          // 0x81c6cbc: 0x0b int  --F------ 0x0000 0x00000004 = 4
!          // 0x81c6cc4: 0x0f oper --F---e-- 0x0000 0x08086b80 = %oparray_pop
!          // 0x81c6ccc: 0x05 mpry --G-rxe-- 0x0039 0x08210dae
!          // Dictionary stack at 0x81b0a00:
!          // 0x81c74a4: 0x02 dict --Gwrx--- 0x081b 0x081b947c
!          // 0x81c74ac: 0x02 dict --Gwrx--- 0x081c 0x0821d0a8
!          // 0x81c74b4: 0x02 dict --Lwrx--- 0x4000 0x081c1388
!          // 0x81c74bc: 0x02 dict --Gwrx--- 0x081b 0x081b947c
!          return 1;
        }
  
!       pDev->pfnGetPrintModeInfo = (PFNGETPRINTMODEINFO)dlsym (pDev->vhOmni, "GetPrintModeInfo");
  
!       if (fDebugOutput) fprintf (stderr, "SetupDevice : dlsym (GetPrintModeInfo) = 0x%08x\n", (int)pDev->pfnGetPrintModeInfo);
  
!       pDev->pfnGetResolutionInfo = (PFNGETRESOLUTIONINFO)dlsym (pDev->vhOmni, "GetResolutionInfo");
  
!       if (fDebugOutput) fprintf (stderr, "SetupDevice : dlsym (GetResolutionInfo) = 0x%08x\n", (int)pDev->pfnGetResolutionInfo);
  
!       pDev->pfnGetMarginInfo = (PFNGETMARGININFO)dlsym (pDev->vhOmni, "GetMarginInfo");
  
!       if (fDebugOutput) fprintf (stderr, "SetupDevice : dlsym (GetMarginInfo) = 0x%08x\n", (int)pDev->pfnGetMarginInfo);
  
!       pDev->pfnBeginJob = (PFNBEGINJOB)dlsym (pDev->vhOmni, "BeginJob");
  
!       if (fDebugOutput) fprintf (stderr, "SetupDevice : dlsym (BeginJob) = 0x%08x\n", (int)pDev->pfnBeginJob);
  
!       pDev->pfnNewFrame = (PFNNEWFRAME)dlsym (pDev->vhOmni, "NewFrame");  //@@04162001
  
-       if (fDebugOutput) fprintf (stderr, "SetupDevice : dlsym (NewFrame) = 0x%08x\n", (int)pDev->pfnNewFrame);
-   
-       pDev->pfnEndJob = (PFNENDJOB)dlsym (pDev->vhOmni, "EndJob");
-   
-       if (fDebugOutput) fprintf (stderr, "SetupDevice : dlsym (EndJob) = 0x%08x\n", (int)pDev->pfnEndJob);
-   
-       pDev->pfnRasterize = (PFNRASTERIZE)dlsym (pDev->vhOmni, "Rasterize");
-   
-       if (fDebugOutput) fprintf (stderr, "SetupDevice : dlsym (Rasterize) = 0x%08x\n", (int)pDev->pfnRasterize);
-   
-       pDev->pfnCreateDevice = (PFNCREATEDEVICE)dlsym (pDev->vhOmni, "createDevice");
-   
-       if (fDebugOutput) fprintf (stderr, "SetupDevice : dlsym (createDevice) = 0x%08x\n", (int)pDev->pfnCreateDevice);
-       //@@04062001
-       pDev->pfnMonoDither = (PFNMONODITHER)dlsym (pDev->vhOmni, "DiffusionDither__FP20_DIFFUSIONDITHERINFOP11_IMAGEINFOSPPUcUi");
-   
-       if (fDebugOutput) fprintf (stderr, "SetupDevice : dlsym (DiffusionDither__FP20_DIFFUSIONDITHERINFOP11_IMAGEINFOSPPUcUi) = 0x%08x\n", (int)pDev->pfnMonoDither);
  
        if (  !pDev->pfnCreateDevice
           || !pDev->pfnBeginJob
           || !pDev->pfnNewFrame            //@@04162001
           || !pDev->pfnEndJob
--- 683,799 ----
            return_error(gs_error_Fatal);
         }
         else
         {
            memset (pDev, 0, sizeof (Omni_Dev));
+           pDev->pcoreOmni = (core_omni_device *)gs_malloc ( 1, sizeof (core_omni_device), "omni/device" );
+ 
+           if(!pDev->pcoreOmni)
+               return_error(gs_error_Fatal);
+ 
+           memset(pDev->pcoreOmni, 0, sizeof(core_omni_device));
+           pDev->pcoreOmni->bPDCDevice = false;
+           memcpy(pDev->pcoreOmni->cSignature, (char *)Signature, 4);
+ 
           // prgxdev->pDev->pszOtherOptions = '\0';
         }
     }
  
!    if (!pDev->hmodOmni)
     {
        pDev->ulPelSizeCorrection = 100;
  
!       for (i = 0; i < 4 && !pDev->hmodOmni; i++)
        {
!           pszDeviceLib = (char *)gs_malloc (1, strlen (cOmnilib)
!                                            + strlen (apszLibraryPaths[i])
!                                            + 1, "Devicestring");
!           if (pszDeviceLib)
!           {
!               sprintf (pszDeviceLib, "%s%s", apszLibraryPaths[i], cOmnilib);
!               pDev->hmodOmni = g_module_open (pszDeviceLib, (GModuleFlags)0);
!           }
!           gs_free (pszDeviceLib,strlen(pszDeviceLib)+1, 1, "Devicestring");
!       }
  
! 
!       if (!pDev->hmodOmni)
!       {
!               // Failure!
!               fprintf (stderr, "\n<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n\n");
!               fprintf (stderr, "Error: Could not load libomni.so!\n\n");
! 
!               // @TBD - why doesnt return_error(gs_error_Fatal) work?
!               //        If it is in, then we get the following:
!               //
!               // Unrecoverable error: rangecheck in .putdeviceprops
!               //
!               // Unexpected interpreter error -15.
!               // Error object: (1488)op_array(586)0x81bc858:.putdeviceprops
!               // Execution stack at 0x81b0940:
!               // 0x81c6c74: 0x0f oper --F---e-- 0x0000 0x08084fcc = %interp_exit
!               // 0x81c6c7c: 0x03 file --G-rxe-- 0x0001 0x081bd010
!               // 0x81c6c84: 0x0e null --F---e-- 0x0000 0x08086b94
!               // 0x81c6c8c: 0x0b int  --F------ 0x01ac 0x00000008 = 8
!               // 0x81c6c94: 0x0b int  --F------ 0x0007 0x00000004 = 4
!               // 0x81c6c9c: 0x0f oper --F---e-- 0x0000 0x08086b80 = %oparray_pop
!               // 0x81c6ca4: 0x05 mpry --G-rxe-- 0x0002 0x0821032c
!               // 0x81c6cac: 0x0e null --F---e-- 0x0000 0x08086b94
!               // 0x81c6cb4: 0x0b int  --F------ 0x0001 0x00000008 = 8
!               // 0x81c6cbc: 0x0b int  --F------ 0x0000 0x00000004 = 4
!               // 0x81c6cc4: 0x0f oper --F---e-- 0x0000 0x08086b80 = %oparray_pop
!               // 0x81c6ccc: 0x05 mpry --G-rxe-- 0x0039 0x08210dae
!               // Dictionary stack at 0x81b0a00:
!               // 0x81c74a4: 0x02 dict --Gwrx--- 0x081b 0x081b947c
!               // 0x81c74ac: 0x02 dict --Gwrx--- 0x081c 0x0821d0a8
!               // 0x81c74b4: 0x02 dict --Lwrx--- 0x4000 0x081c1388
!               // 0x81c74bc: 0x02 dict --Gwrx--- 0x081b 0x081b947c
!               return 1;
        }
  
!       g_module_symbol (pDev->hmodOmni, "GetPrintModeInfo", (gpointer *)&pDev->pfnGetPrintModeInfo);
! 
!       if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (GetPrintModeInfo) = 0x%08x\n", (int)pDev->pfnGetPrintModeInfo);
! 
!       g_module_symbol (pDev->hmodOmni, "GetResolutionInfo", (gpointer *)&pDev->pfnGetResolutionInfo);
! 
!       if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (GetResolutionInfo) = 0x%08x\n", (int)pDev->pfnGetResolutionInfo);
! 
!       g_module_symbol (pDev->hmodOmni, "GetMarginInfo", (gpointer *)&pDev->pfnGetMarginInfo);
! 
!       if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (GetMarginInfo) = 0x%08x\n", (int)pDev->pfnGetMarginInfo);
! 
!       g_module_symbol (pDev->hmodOmni, "BeginJob", (gpointer *)&pDev->pfnBeginJob);
! 
!       if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (BeginJob) = 0x%08x\n", (int)pDev->pfnBeginJob);
! 
!       g_module_symbol (pDev->hmodOmni, "NewFrame", (gpointer *)&pDev->pfnNewFrame);
! 
!       if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (NewFrame) = 0x%08x\n", (int)pDev->pfnNewFrame);
! 
!       g_module_symbol (pDev->hmodOmni, "EndJob", (gpointer *)&pDev->pfnEndJob);
  
!       if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (EndJob) = 0x%08x\n", (int)pDev->pfnEndJob);
  
!       g_module_symbol (pDev->hmodOmni, "Rasterize", (gpointer *)&pDev->pfnRasterize);
  
!       if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (Rasterize) = 0x%08x\n", (int)pDev->pfnRasterize);
  
!       g_module_symbol (pDev->hmodOmni, "createDevice", (gpointer *)&pDev->pfnCreateDevice);
  
!       if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (createDevice) = 0x%08x\n", (int)pDev->pfnCreateDevice);
  
! //      g_module_symbol (pDev->hmodOmni, "DiffusionDither__FP20_DIFFUSIONDITHERINFOP11_IMAGEINFOSPPUcUi", (gpointer *)&pDev->pfnMonoDither);
!       g_module_symbol (pDev->hmodOmni, "DiffusionDither", (gpointer *)&pDev->pfnMonoDither);
  
! //      if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (DiffusionDither__FP20_DIFFUSIONDITHERINFOP11_IMAGEINFOSPPUcUi) = 0x%08x\n", (int)pDev->pfnMonoDither);
!       if (fDebugOutput) fprintf (stderr, "SetupDevice : g_module_symbol (DiffusionDither) = 0x%08x\n", (int)pDev->pfnMonoDither);
  
! //      g_module_symbol (pDev->hmodOmni, "getInterfaceVersion__FPvPc", (gpointer *)&pDev->pfnGetVersion);
!       g_module_symbol (pDev->hmodOmni, "getInterfaceVersion", (gpointer *)&pDev->pfnGetVersion);
!           
  
  
        if (  !pDev->pfnCreateDevice
           || !pDev->pfnBeginJob
           || !pDev->pfnNewFrame            //@@04162001
           || !pDev->pfnEndJob
***************
*** 725,738 ****
           )
        {
           // Failure!
           fprintf (stderr, "\n<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n\n");
           fprintf (stderr, "Error: Could not load required entry point from libomni.so!\n\n");
!   
!          dlclose (pDev->vhOmni);
!          pDev->vhOmni = 0;
!   
           // @TBD - why doesnt return_error(gs_error_Fatal) work? (see above)
           return 1;
        }
  
     }
--- 805,818 ----
           )
        {
           // Failure!
           fprintf (stderr, "\n<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n\n");
           fprintf (stderr, "Error: Could not load required entry point from libomni.so!\n\n");
! 
!          g_module_close (pDev->hmodOmni);
!          pDev->hmodOmni = 0;
! 
           // @TBD - why doesnt return_error(gs_error_Fatal) work? (see above)
           return 1;
        }
  
     }
***************
*** 740,750 ****
  //   device name in structure - need to fail if none
     fname = deffname;
     iReturnCode = param_read_string(plist,"DeviceName",&fname);
     if(0 > iReturnCode)
     {
!       pDev->cDeviceName[0] = '\0';
        if(iReturnCode < 0)
        {
            iReturnCode = param_read_null(plist,"DeviceName");
            if(iReturnCode != 0)
              fprintf(stderr, "Error Reading DeviceName parameter\n");
--- 820,830 ----
  //   device name in structure - need to fail if none
     fname = deffname;
     iReturnCode = param_read_string(plist,"DeviceName",&fname);
     if(0 > iReturnCode)
     {
!       pDev->pcoreOmni->cDeviceName[0] = '\0';
        if(iReturnCode < 0)
        {
            iReturnCode = param_read_null(plist,"DeviceName");
            if(iReturnCode != 0)
              fprintf(stderr, "Error Reading DeviceName parameter\n");
***************
*** 752,774 ****
     }
     else
     {
        if((iReturnCode < 1) && (fname.size > 0))
        {
!           memcpy (pDev->cDeviceName, fname.data, fname.size );
!           pDev->cDeviceName[fname.size] = '\0';
        }
  
     }
  
     // set debugging file name
     fname = deffname;
     iReturnCode = 0;
     iReturnCode = param_read_string(plist,"dbgout",&fname);
     if(0 > iReturnCode)
     {
!       pDev->cDebugFile[0] = '\0';
        if(iReturnCode < 0)
        {
            iReturnCode = param_read_null(plist,"dbgout");
            if(iReturnCode != 0)
              fprintf(stderr, "Error Reading dbgout parameter\n");
--- 832,854 ----
     }
     else
     {
        if((iReturnCode < 1) && (fname.size > 0))
        {
!           memcpy (pDev->pcoreOmni->cDeviceName, fname.data, fname.size );
!           pDev->pcoreOmni->cDeviceName[fname.size] = '\0';
        }
  
     }
  
     // set debugging file name
     fname = deffname;
     iReturnCode = 0;
     iReturnCode = param_read_string(plist,"dbgout",&fname);
     if(0 > iReturnCode)
     {
!       pDev->pcoreOmni->cDebugFile[0] = '\0';
        if(iReturnCode < 0)
        {
            iReturnCode = param_read_null(plist,"dbgout");
            if(iReturnCode != 0)
              fprintf(stderr, "Error Reading dbgout parameter\n");
***************
*** 776,787 ****
     }
     else
     {
        if((iReturnCode < 1) && (fname.size > 0))
        {
!           memcpy ( pDev->cDebugFile, fname.data, fname.size );
!           pDev->cDebugFile[fname.size] = '\0';
        }
     }
  
     // set Async option
     fname = deffname;
--- 856,867 ----
     }
     else
     {
        if((iReturnCode < 1) && (fname.size > 0))
        {
!           memcpy ( pDev->pcoreOmni->cDebugFile, fname.data, fname.size );
!           pDev->pcoreOmni->cDebugFile[fname.size] = '\0';
        }
     }
  
     // set Async option
     fname = deffname;
***************
*** 840,853 ****
     }
     else
     {
         if((iReturnCode < 1) && (fname.size > 0))
         {
!            if(!pDev->pszOtherOptions)
!              pDev->pszOtherOptions = (char *) gs_malloc(1,fname.size+1, "Option String");
!            memcpy ( pDev->pszOtherOptions, fname.data, fname.size );
!            pDev->pszOtherOptions[fname.size] = '\0';
         }
     }
  
     /*
      *  Set user options for monodither by GS
--- 920,933 ----
     }
     else
     {
         if((iReturnCode < 1) && (fname.size > 0))
         {
!            if(!pDev->pcoreOmni->pszJobOptions)
!              pDev->pcoreOmni->pszJobOptions = (char *) gs_malloc(1,fname.size+1, "Option String");
!            memcpy ( pDev->pcoreOmni->pszJobOptions, fname.data, fname.size );
!            pDev->pcoreOmni->pszJobOptions[fname.size] = '\0';
         }
     }
  
     /*
      *  Set user options for monodither by GS
***************
*** 871,881 ****
             memcpy ( pDev->cMonoDither, fname.data, fname.size );
             pDev->cMonoDither[fname.size] = '\0';
  
             if(!strcmp(pDev->cMonoDither, "GSMONO"))
             {
!                
                 if (fDebugOutput) fprintf(stderr,"turning on GSMONO dither\n");
                 pDev->iGSMono = 1;
             }
             else
             {
--- 951,961 ----
             memcpy ( pDev->cMonoDither, fname.data, fname.size );
             pDev->cMonoDither[fname.size] = '\0';
  
             if(!strcmp(pDev->cMonoDither, "GSMONO"))
             {
! 
                 if (fDebugOutput) fprintf(stderr,"turning on GSMONO dither\n");
                 pDev->iGSMono = 1;
             }
             else
             {
***************
*** 886,898 ****
  
     /*
      *  Set user options for client / server function
      */
  
-    pDev->iUseServer = 0;                                            //@@05092001
     fname = deffname;                                                //@@05092001
     iReturnCode = param_read_string(plist,"server",&fname);          //@@05092001
     if(0 > iReturnCode)                                              //@@05092001
     {                                                                //@@05092001
        if(iReturnCode < 0)                                           //@@05092001
        {                                                             //@@05092001
            iReturnCode = param_read_null(plist,"server");            //@@05092001
--- 966,978 ----
  
     /*
      *  Set user options for client / server function
      */
  
     fname = deffname;                                                //@@05092001
     iReturnCode = param_read_string(plist,"server",&fname);          //@@05092001
+ 
     if(0 > iReturnCode)                                              //@@05092001
     {                                                                //@@05092001
        if(iReturnCode < 0)                                           //@@05092001
        {                                                             //@@05092001
            iReturnCode = param_read_null(plist,"server");            //@@05092001
***************
*** 900,969 ****
              fprintf(stderr, "Error Reading server parameter\n");    //@@05092001
        }                                                             //@@05092001
     }                                                                //@@05092001
     else                                                             //@@05092001
     {                                                                //@@05092001
!        if((iReturnCode < 1) && (fname.size > 0))                    //@@05092001
!        {                                                            //@@05092001
!            memcpy ( pDev->cServerFile, fname.data, fname.size );    //@@05092001
!            pDev->cServerFile[fname.size] = '\0';                    //@@05092001
!                                                                     //@@05092001
!          //  if(!strcmp(pDev->cMonoDither, "TRUE"))                 //@@05092001
!            if(pDev->cServerFile[0])                                 //@@05092001
!            {                                                        //@@05092001
!                pDev->iUseServer = 1;                                //@@05092001
!            }                                                        //@@05092001
!                                                                     //@@05092001
!        }                                                            //@@05092001
     }                                                                //@@05092001
  
     if(pDev->iSetup != 1)
     {
        // create a device based on the user supplied inputs
        // To-Do - free the device
  
        if (fDebugOutput) fprintf(stderr,"setting following options on CreateDevice\n");
!       if (fDebugOutput) fprintf(stderr,"DeviceName= %s\n", pDev->cDeviceName );
!       if (fDebugOutput) fprintf(stderr,"%s\n", pDev->pszOtherOptions);
!       if (fDebugOutput) fprintf(stderr,"debug parameter = %s \n", pDev->cDebugFile );
  
        /*
         *  Create a device definition by using the input parameters as the
         *  the defining factors
         */
  
!       if (!pDev->cDeviceName[0])
        {
            bRet = gdev_prn_put_params ((gx_device *)prgxdev, plist);
            return bRet;
        }
  
!       if(pDev->iUseServer && pDev->cServerFile[0])                  //@@05092001
!       {                                                             //@@05092001
!                                                                     //@@05092001
!         pDev->ProxyFile = fopen(pDev->cServerFile, "wb");           //@@05092001
!                                                                     //@@05092001
!       }                                                             //@@05092001
  
-       pDev->pDevice = pDev->pfnCreateDevice(pDev->cDeviceName,
-                                             pDev->pOutputObject,
-                                             &pDev->vhDevice  ,
-                                             pDev->cDebugFile ,
-                                             pDev->pszOtherOptions,
-                                             pDev->iUseServer,       //@@05092001
-                                             pDev->ProxyFile);       //@@05092001
  
!       if (!pDev->pDevice)
        {
           return_error(gs_error_Fatal);  // fail if no device was created
        }
        else
        {
!           if (fDebugOutput) fprintf(stderr,"Device = %s ", pDev->cDeviceName );
        }
  
!       bRet = pDev->pfnGetPrintModeInfo (pDev->pDevice, &prtMode);
  
        if(bRet)
        {          // turn off Ghostscript mono if we are not in mono mode
            if((prtMode.iBitCount > 1) && pDev->iGSMono )
            {
--- 980,1155 ----
              fprintf(stderr, "Error Reading server parameter\n");    //@@05092001
        }                                                             //@@05092001
     }                                                                //@@05092001
     else                                                             //@@05092001
     {                                                                //@@05092001
!        if( !iReturnCode) 
!        {
!            if (fDebugOutput) fprintf(stderr, "Utilizing Server\n");   
!            pDev->iUseServer = 1;                                            
!        }
! 
!    }                                                                //@@05092001
! 
!    /*
!     *  Set user options for dialog function
!     */
! 
!    fname = deffname;                                                //@@05092001
!    iReturnCode = param_read_string(plist,"jobdialog",&fname);  //@@05092001
! 
!    if(0 > iReturnCode)                                              //@@05092001
!    {                                                                //@@05092001
!       if(iReturnCode < 0)                                           //@@05092001
!       {                                                             //@@05092001
!           iReturnCode = param_read_null(plist,"jobdialog");     //@@05092001
!           if(iReturnCode != 0)                                      //@@05092001
!             fprintf(stderr, "Error Reading server parameter\n");    //@@05092001
!       }                                                             //@@05092001
!    }                                                                //@@05092001
!    else                                                             //@@05092001
!    {                                                                //@@05092001
!        if( !iReturnCode) 
!        {
!            if (fDebugOutput) fprintf(stderr, "Utilizing dialog\n");   
!            pDev->iUseDialog = 1;                                            
!        }
! 
     }                                                                //@@05092001
  
     if(pDev->iSetup != 1)
     {
        // create a device based on the user supplied inputs
        // To-Do - free the device
  
        if (fDebugOutput) fprintf(stderr,"setting following options on CreateDevice\n");
!       if (fDebugOutput) fprintf(stderr,"DeviceName= %s\n", pDev->pcoreOmni->cDeviceName );
!       if (fDebugOutput) fprintf(stderr,"%s\n", pDev->pcoreOmni->pszJobOptions);
!       if (fDebugOutput) fprintf(stderr,"debug parameter = %s \n", pDev->pcoreOmni->cDebugFile );
  
        /*
         *  Create a device definition by using the input parameters as the
         *  the defining factors
         */
  
!       if (!pDev->pcoreOmni->cDeviceName[0])
        {
            bRet = gdev_prn_put_params ((gx_device *)prgxdev, plist);
            return bRet;
        }
  
!       // Removed following code so commandline server invocation is
!       // just -sserver  @@01302002
! 
! //      if(pDev->iUseServer && pDev->cServerFile[0])                  //@@05092001
! //      {                                                             //@@05092001
! //                                                                    //@@05092001
! //        pDev->ProxyFile = fopen(pDev->cServerFile, "wb");           //@@05092001
! //                                                                    //@@05092001
! //      }                                                             //@@05092001
! 
! /*****************************************************************/
!    if(!pDev->pcoreOmni->pszJobOptions && pDev->iUseDialog)
!    {
! 		
! 	 int iLength=0;
!      char *pszSelectedJobProperties;
!      int (*pfnJobDialog) (char[] , char **);
!      int (*pfnFreeDialogMemory) (char **);
! 
! 
! 	 GModule *pModule = 0; 
!      for (i = 0; i < 4 && !pModule; i++)
!      {
!          pszDeviceLib = (char *)gs_malloc (1, strlen (cDialogName)
!                                           + strlen (apszLibraryPaths[i])
!                                           + 1, "Devicestring");
!          pszDeviceLib[0] = '\0';
! 
!          if (pszDeviceLib)
!          {
!              sprintf (pszDeviceLib, "%s%s", apszLibraryPaths[i], cDialogName);
!              if (fDebugOutput) fprintf (stderr, "attempting to load - %s\n", pszDeviceLib);
!              pModule = g_module_open(pszDeviceLib,(GModuleFlags)0); 
!          }
!          gs_free (pszDeviceLib,strlen(pszDeviceLib)+1, 1, "Devicestring");
!      }
! 
!      if(!pModule)
!      {
!        fprintf(stderr, "Unable to open <<%s>>.",cDialogName);
! 	 }
! 	 else
! 	 {       
!        g_module_symbol(pModule, "GetOmniJobProperties", (gpointer *) &pfnJobDialog);
!        if(pfnJobDialog)
!        {
!            pfnJobDialog(pDev->pcoreOmni->cDeviceName, &pszSelectedJobProperties);
!            iLength = strlen(pszSelectedJobProperties);
!            if(!pDev->pcoreOmni->pszJobOptions)
!                 pDev->pcoreOmni->pszJobOptions = (char *)gs_malloc(1,iLength+1,"Option String");
! 
!            strcpy(pDev->pcoreOmni->pszJobOptions, pszSelectedJobProperties);
! 
!            if (fDebugOutput) fprintf(stderr, "options = %s\n", pDev->pcoreOmni->pszJobOptions);
! 
!            g_module_symbol(pModule, "FreeOmniJobProperties", (gpointer *) &pfnFreeDialogMemory);
!            if(pfnFreeDialogMemory)
!            {
!                pfnFreeDialogMemory(&pszSelectedJobProperties); 
!                if (fDebugOutput) fprintf(stderr, "Freeing Dialog Memory\n");
!            }
  
  
!        }
! 	 }
! 
!    }	 
! /**********************************************************************/      
! 
!       if(pDev->iUseServer)
!       {
!           pDev->pcoreOmni->bPDCDevice = true;  
!           if (fDebugOutput) fprintf(stderr, "utilizing server\n");
!       }
!       else
!           pDev->pcoreOmni->bPDCDevice = false;  
! 
!       pDev->pcoreOmni->pDevice = pDev->pfnCreateDevice(pDev->pcoreOmni->cDeviceName,
!                                                        pDev->pOutputObject,
!                                                       &pDev->hmodDevice,
!                                                        pDev->pcoreOmni->cDebugFile,
!                                                        pDev->pcoreOmni->pszJobOptions,
!                                                        pDev->iUseServer,       //@@05092001
!                                                        pDev->ProxyFile);       //@@05092001
! 
! 
! 
!       if (!pDev->pcoreOmni->pDevice)
        {
           return_error(gs_error_Fatal);  // fail if no device was created
        }
        else
        {
!           if (fDebugOutput) fprintf(stderr,"Device = %s ", pDev->pcoreOmni->cDeviceName );
!           if(pDev->pcoreOmni->bPDCDevice) 
!               pDev->pcoreOmni->pPDCDevice = pDev->pcoreOmni->pDevice;
        }
+            // get the omni version in case we need it
+       if(pDev->pfnGetVersion)
+       {
+          pDev->pfnGetVersion((void*) pDev->pcoreOmni, pDev->pcoreOmni->cOmniVersion);
+          if (fDebugOutput) fprintf(stderr, "Omni version = %s \n",pDev->pcoreOmni->cOmniVersion );
+          pDev->pCallPtr = (void *) pDev->pcoreOmni;
+       }
+       else
+       {
+           pDev->pCallPtr = (void *) pDev->pcoreOmni->pDevice ;
+       }
+ 
  
!       bRet = pDev->pfnGetPrintModeInfo ((void*) pDev->pCallPtr, &prtMode);
  
        if(bRet)
        {          // turn off Ghostscript mono if we are not in mono mode
            if((prtMode.iBitCount > 1) && pDev->iGSMono )
            {
***************
*** 971,998 ****
                pDev->iGSMono = 0;
            }
        }
                           //** this routine is called multiple times
        pDev->iSetup = 1;  //** don't go setting up new devices
! 
!       if(!pDev->iUseServer)                                         //@@05092001
!       {
!           pDev->pfnDeleteDevice = (PFNDELETEDEVICE)dlsym (pDev->vhDevice, "deleteDevice__FP6Device");
!           if (fDebugOutput) fprintf (stderr, "SetupDevice : dlsym (deleteDevice__FP6Device) = 0x%08x\n", (int)pDev->pfnDeleteDevice);
!       }
! 
        // get the hardware resolution information
! 
!       bRet = pDev->pfnGetResolutionInfo (pDev->pDevice, &hwRes);
  
        if(!bRet)
            return_error(gs_error_Fatal);
  
        // get the hardware page margins information
  
!       bRet = pDev->pfnGetMarginInfo (pDev->pDevice, &hwMargins);
! 
        if(!bRet)
            return_error(gs_error_Fatal);
  
        /*
         *  We have to let GS know about our page and resolution parameters
--- 1157,1178 ----
                pDev->iGSMono = 0;
            }
        }
                           //** this routine is called multiple times
        pDev->iSetup = 1;  //** don't go setting up new devices
!       
        // get the hardware resolution information
!       
!       bRet = pDev->pfnGetResolutionInfo ((void*) pDev->pCallPtr, &hwRes);
  
        if(!bRet)
            return_error(gs_error_Fatal);
  
        // get the hardware page margins information
  
!       bRet = pDev->pfnGetMarginInfo ((void*) pDev->pCallPtr, &hwMargins);
!       
        if(!bRet)
            return_error(gs_error_Fatal);
  
        /*
         *  We have to let GS know about our page and resolution parameters
***************
*** 1005,1015 ****
        // does not seem like pels works correctly for margins so lets set the margins
        // using points instead
  
        // left margin
        prgxdev->HWMargins[0] = (float) hwMargins.fLeftClip/25400.0 *72.0;           //@@05092001A
!                                                                                    
        // bottom margin
        prgxdev->HWMargins[1] = (float) hwMargins.fBottomClip/25400.0 *72.0;         //@@05092001A
  
        // right margin
        prgxdev->HWMargins[2] = (float) hwMargins.fRightClip/25400.0 *72.0;          //@@05092001A
--- 1185,1195 ----
        // does not seem like pels works correctly for margins so lets set the margins
        // using points instead
  
        // left margin
        prgxdev->HWMargins[0] = (float) hwMargins.fLeftClip/25400.0 *72.0;           //@@05092001A
! 
        // bottom margin
        prgxdev->HWMargins[1] = (float) hwMargins.fBottomClip/25400.0 *72.0;         //@@05092001A
  
        // right margin
        prgxdev->HWMargins[2] = (float) hwMargins.fRightClip/25400.0 *72.0;          //@@05092001A
***************
*** 1107,1127 ****
  
      pDevStruct pDev = pasyncDev->pDev;
  
      // Do a new_frame if not first page
  
!     if(!pDev || !pDev->pDevice )
      {
          fprintf(stderr, "\n<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n\n");
          fprintf(stderr, "Error: -sDeviceName=XXX is not specified!\n\n");
          return_error(gs_error_Fatal);
      }
  
      pDev->iPage++;
      pDev->iPageNumber++;  //keep track of the page @@04162001
  
!     bRet = pDev->pfnGetPrintModeInfo (pasyncDev->pDev->pDevice, &prtMode);
  
      iNumColors = 1 << prtMode.iBitCount;
  
      // Allocate a full bitmapinfo2 and bitmap header message
      iBytesToAlloc = sizeof (BITMAPINFO2);
--- 1287,1307 ----
  
      pDevStruct pDev = pasyncDev->pDev;
  
      // Do a new_frame if not first page
  
!     if(!pDev || !pDev->pcoreOmni->pDevice )
      {
          fprintf(stderr, "\n<<<<<<<<<<<<<<<<<<<<<< ERROR >>>>>>>>>>>>>>>>>>>>>>>\n\n");
          fprintf(stderr, "Error: -sDeviceName=XXX is not specified!\n\n");
          return_error(gs_error_Fatal);
      }
  
      pDev->iPage++;
      pDev->iPageNumber++;  //keep track of the page @@04162001
  
!     bRet = pDev->pfnGetPrintModeInfo ((void*) pasyncDev->pDev->pCallPtr, &prtMode);
  
      iNumColors = 1 << prtMode.iBitCount;
  
      // Allocate a full bitmapinfo2 and bitmap header message
      iBytesToAlloc = sizeof (BITMAPINFO2);
***************
*** 1287,1299 ****
     rectPageLocation.xLeft    = 0;
  
     rectPageLocation.xRight   = pasyncDev->width;
     //@@04162001
     if(pDev->iPageNumber == 1)
!       pDev->pfnBeginJob (pasyncDev->pDev->pDevice, prn_stream);
     else
!       pDev->pfnNewFrame (pasyncDev->pDev->pDevice);
  
  
  // rectPageLocation.yTop = rectPageLocation.yBottom  = 0;  @@10172000
  
     rectPageLocation.yTop =  pasyncDev->height-1;       // @@10172000
--- 1467,1487 ----
     rectPageLocation.xLeft    = 0;
  
     rectPageLocation.xRight   = pasyncDev->width;
     //@@04162001
     if(pDev->iPageNumber == 1)
!    {
!        pDev->pcoreOmni->pfile = prn_stream;
! 
!        pDev->pfnBeginJob ((void*) pasyncDev->pDev->pCallPtr, prn_stream);
! 
!           // copy the PDC pointer to the pDevice since pDevice is defaulted throughout code
!        if(pasyncDev->pDev->pcoreOmni->bPDCDevice)
!            pasyncDev->pDev->pcoreOmni->pDevice = pasyncDev->pDev->pcoreOmni->pPDCDevice;
!    }
     else
!       pDev->pfnNewFrame ((void*) pasyncDev->pDev->pCallPtr);
  
  
  // rectPageLocation.yTop = rectPageLocation.yBottom  = 0;  @@10172000
  
     rectPageLocation.yTop =  pasyncDev->height-1;       // @@10172000
***************
*** 1382,1392 ****
             // If this in a mono device, we need to send the mono data to the device and
             // not the color
  
             if(pMonoData && !pDev->iGSMono)//@@04252001
             {
!               pDev->pfnRasterize (pasyncDev->pDev->pDevice,
                                    pMonoData,
                                    pbmi,
                                    &sizelPage,
                                    &rectPageLocation,
                                    BITBLT_BITMAP);
--- 1570,1580 ----
             // If this in a mono device, we need to send the mono data to the device and
             // not the color
  
             if(pMonoData && !pDev->iGSMono)//@@04252001
             {
!               pDev->pfnRasterize ((void*) pasyncDev->pDev->pCallPtr,
                                    pMonoData,
                                    pbmi,
                                    &sizelPage,
                                    &rectPageLocation,
                                    BITBLT_BITMAP);
***************
*** 1399,1419 ****
                pMonoData = NULL;
  
             }
             else
             {  // non-mono device -- Send the rgb bitmap to the dither and rasterize routines
!               fprintf(stderr, "rendering band lines %d - %d w/%d \n", (int)rectPageLocation.yTop, (int)rectPageLocation.yBottom, iYBand);
  
                if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
                if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
                if (fDebugOutput) fprintf(stderr, "Number of lines in band = %d\n", iYBand);
                if (fDebugOutput) fprintf(stderr, "rectPageLocation - Top = %ld\n", rectPageLocation.yTop);
                if (fDebugOutput) fprintf(stderr, "rectPageLocation - Bot = %ld\n", rectPageLocation.yBottom);
                if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
                if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
  
!               pDev->pfnRasterize (pasyncDev->pDev->pDevice,
                                    pBitmapTop - ((iYBand-1) * uiBytesPerLine),
                                    pbmi,
                                    &sizelPage,
                                    &rectPageLocation,
                                    BITBLT_BITMAP);
--- 1587,1607 ----
                pMonoData = NULL;
  
             }
             else
             {  // non-mono device -- Send the rgb bitmap to the dither and rasterize routines
!               if (fDebugOutput) fprintf(stderr, "rendering band lines %d - %d w/%d \n", (int)rectPageLocation.yTop, (int)rectPageLocation.yBottom, iYBand);
  
                if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
                if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
                if (fDebugOutput) fprintf(stderr, "Number of lines in band = %d\n", iYBand);
                if (fDebugOutput) fprintf(stderr, "rectPageLocation - Top = %ld\n", rectPageLocation.yTop);
                if (fDebugOutput) fprintf(stderr, "rectPageLocation - Bot = %ld\n", rectPageLocation.yBottom);
                if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
                if (fDebugOutput) fprintf(stderr, "***************************************************************\n");
  
!               pDev->pfnRasterize ((void*) pasyncDev->pDev->pCallPtr,
                                    pBitmapTop - ((iYBand-1) * uiBytesPerLine),
                                    pbmi,
                                    &sizelPage,
                                    &rectPageLocation,
                                    BITBLT_BITMAP);
***************
*** 1524,1534 ****
  
  /* Buffer a (partial) rasterized page & optionally print result multiple times. */
  private int
  BufferPage(gx_device_printer *pgx_prt_dev, FILE *file, int num_copies)
  {
! #if 1
      /* locate_overlay_buffer is gone, so for now async printing is disabled */
      return gs_note_error(gs_error_undefined);
  #else
      gx_device_omni * const pasyncDev = (gx_device_omni *)pgx_prt_dev;
      gx_device * const pgx_dev = (gx_device *)pgx_prt_dev;
--- 1712,1722 ----
  
  /* Buffer a (partial) rasterized page & optionally print result multiple times. */
  private int
  BufferPage(gx_device_printer *pgx_prt_dev, FILE *file, int num_copies)
  {
! #ifndef OMNI_ASYNC
      /* locate_overlay_buffer is gone, so for now async printing is disabled */
      return gs_note_error(gs_error_undefined);
  #else
      gx_device_omni * const pasyncDev = (gx_device_omni *)pgx_prt_dev;
      gx_device * const pgx_dev = (gx_device *)pgx_prt_dev;
Common subdirectories: gs-6.53_new/ghostscript-6.53/src/temp and gs-6.53_newb/ghostscript-6.53/src/temp
diff -C5 --unidirectional-new-file gs-6.53_new/ghostscript-6.53/src/unix-gcc.mak gs-6.53_newb/ghostscript-6.53/src/unix-gcc.mak
*** gs-6.53_new/ghostscript-6.53/src/unix-gcc.mak	Mon Feb  4 18:20:42 2002
--- gs-6.53_newb/ghostscript-6.53/src/unix-gcc.mak	Wed Feb 13 13:08:32 2002
***************
*** 207,221 ****
--- 207,223 ----
  # ------ Platform-specific options ------ #
  
  # Define the name of the C compiler.
  
  CC=gcc
+ CCPLUS=c++
  
  # Define the name of the linker for the final link step.
  # Normally this is the same as the C compiler.
  
  CCLD=$(CC)
+ CCLDPLUS=$(CCPLUS)
  
  # Define the default gcc flags.
  # Note that depending whether or not we are running a version of gcc with
  # the 2.7.0-2.7.2 optimizer bug, either "-Dconst=" or
  # "-Wcast-qual -Wwrite-strings" is automatically included.
***************
*** 392,402 ****
  #DEVICE_DEVS18=
  #DEVICE_DEVS19=
  #DEVICE_DEVS20=
  
  DEVICE_DEVS1=$(DD)bmpmono.dev $(DD)bmpgray.dev $(DD)bmpsep1.dev $(DD)bmpsep8.dev $(DD)bmp16.dev $(DD)bmp256.dev $(DD)bmp16m.dev $(DD)bmp32b.dev
! DEVICE_DEVS2=
  DEVICE_DEVS3=$(DD)deskjet.dev $(DD)djet500.dev $(DD)laserjet.dev $(DD)ljetplus.dev $(DD)ljet2p.dev $(DD)ljet3.dev $(DD)ljet3d.dev $(DD)ljet4.dev $(DD)ljet4d.dev $(DD)lj5mono.dev $(DD)lj5gray.dev
  DEVICE_DEVS4=$(DD)cdeskjet.dev $(DD)cdjcolor.dev $(DD)cdjmono.dev $(DD)cdj550.dev $(DD)pj.dev $(DD)pjxl.dev $(DD)pjxl300.dev
  DEVICE_DEVS5=$(DD)uniprint.dev $(DD)ijs.dev
  DEVICE_DEVS6=$(DD)bj10e.dev $(DD)bj200.dev $(DD)bjc600.dev $(DD)bjc800.dev
  DEVICE_DEVS7=$(DD)faxg3.dev $(DD)faxg32d.dev $(DD)faxg4.dev
--- 394,404 ----
  #DEVICE_DEVS18=
  #DEVICE_DEVS19=
  #DEVICE_DEVS20=
  
  DEVICE_DEVS1=$(DD)bmpmono.dev $(DD)bmpgray.dev $(DD)bmpsep1.dev $(DD)bmpsep8.dev $(DD)bmp16.dev $(DD)bmp256.dev $(DD)bmp16m.dev $(DD)bmp32b.dev
! DEVICE_DEVS2=$(DD)omni.dev
  DEVICE_DEVS3=$(DD)deskjet.dev $(DD)djet500.dev $(DD)laserjet.dev $(DD)ljetplus.dev $(DD)ljet2p.dev $(DD)ljet3.dev $(DD)ljet3d.dev $(DD)ljet4.dev $(DD)ljet4d.dev $(DD)lj5mono.dev $(DD)lj5gray.dev
  DEVICE_DEVS4=$(DD)cdeskjet.dev $(DD)cdjcolor.dev $(DD)cdjmono.dev $(DD)cdj550.dev $(DD)pj.dev $(DD)pjxl.dev $(DD)pjxl300.dev
  DEVICE_DEVS5=$(DD)uniprint.dev $(DD)ijs.dev
  DEVICE_DEVS6=$(DD)bj10e.dev $(DD)bj200.dev $(DD)bjc600.dev $(DD)bjc800.dev
  DEVICE_DEVS7=$(DD)faxg3.dev $(DD)faxg32d.dev $(DD)faxg4.dev
diff -C5 --unidirectional-new-file gs-6.53_new/ghostscript-6.53/src/unixlink.mak gs-6.53_newb/ghostscript-6.53/src/unixlink.mak
*** gs-6.53_new/ghostscript-6.53/src/unixlink.mak	Tue Jun  5 01:32:07 2001
--- gs-6.53_newb/ghostscript-6.53/src/unixlink.mak	Wed Feb 13 13:10:26 2002
***************
*** 61,74 ****
  # Here is the final link step.  The stuff with LD_RUN_PATH is for SVR4
  # systems with dynamic library loading; I believe it's harmless elsewhere.
  # The resetting of the environment variables to empty strings is for SCO Unix,
  # which has limited environment space.
  ldt_tr=$(PSOBJ)ldt.tr
  $(GS_XE): $(ld_tr) $(ECHOGS_XE) $(XE_ALL)
! 	$(ECHOGS_XE) -w $(ldt_tr) -n - $(CCLD) $(LDFLAGS) -o $(GS_XE)
  	$(ECHOGS_XE) -a $(ldt_tr) -n -s $(PSOBJ)gs.$(OBJ) -s
  	cat $(ld_tr) >>$(ldt_tr)
  	$(ECHOGS_XE) -a $(ldt_tr) -s - $(EXTRALIBS) $(STDLIBS)
  	if [ x$(XLIBDIR) != x ]; then LD_RUN_PATH=$(XLIBDIR); export LD_RUN_PATH; fi; \
  	XCFLAGS= XINCLUDE= XLDFLAGS= XLIBDIRS= XLIBS= \
  	FEATURE_DEVS= DEVICE_DEVS= DEVICE_DEVS1= DEVICE_DEVS2= DEVICE_DEVS3= \
  	DEVICE_DEVS4= DEVICE_DEVS5= DEVICE_DEVS6= DEVICE_DEVS7= DEVICE_DEVS8= \
--- 61,81 ----
  # Here is the final link step.  The stuff with LD_RUN_PATH is for SVR4
  # systems with dynamic library loading; I believe it's harmless elsewhere.
  # The resetting of the environment variables to empty strings is for SCO Unix,
  # which has limited environment space.
  ldt_tr=$(PSOBJ)ldt.tr
+  
+ # @TBD - what to do on systems that dont have glib?
+ LIBDLOPEN= `glib-config --libs gmodule`
+ # @TBD - we still need the stdc++ library otherwise we trap in exit() in gp_unix.c:60
+ LIBCPP= -lstdc++
+ CCLD=$(CCLDPLUS)
  $(GS_XE): $(ld_tr) $(ECHOGS_XE) $(XE_ALL)
! 	$(ECHOGS_XE) -w $(ldt_tr) -n - $(CCLD) $(LDFLAGS) $(LIBFLAG) -o $(GS_XE)
  	$(ECHOGS_XE) -a $(ldt_tr) -n -s $(PSOBJ)gs.$(OBJ) -s
  	cat $(ld_tr) >>$(ldt_tr)
+ 	$(ECHOGS_XE) -a $(ldt_tr) -n - $(LIBDLOPEN) $(LIBCPP)
  	$(ECHOGS_XE) -a $(ldt_tr) -s - $(EXTRALIBS) $(STDLIBS)
  	if [ x$(XLIBDIR) != x ]; then LD_RUN_PATH=$(XLIBDIR); export LD_RUN_PATH; fi; \
  	XCFLAGS= XINCLUDE= XLDFLAGS= XLIBDIRS= XLIBS= \
  	FEATURE_DEVS= DEVICE_DEVS= DEVICE_DEVS1= DEVICE_DEVS2= DEVICE_DEVS3= \
  	DEVICE_DEVS4= DEVICE_DEVS5= DEVICE_DEVS6= DEVICE_DEVS7= DEVICE_DEVS8= \
